<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Welcome to Pandora's Box]]></title>
  <link href="http://hustcalm.me/atom.xml" rel="self"/>
  <link href="http://hustcalm.me/"/>
  <updated>2021-01-20T00:19:40-08:00</updated>
  <id>http://hustcalm.me/</id>
  <author>
    <name><![CDATA[Lihang Li]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bye, 2020]]></title>
    <link href="http://hustcalm.me/blog/2021/01/15/bye-2020/"/>
    <updated>2021-01-15T09:58:05-08:00</updated>
    <id>http://hustcalm.me/blog/2021/01/15/bye-2020</id>
    <content type="html"><![CDATA[<p>在30岁的这一天，还是觉得应该写点什么，正好也是对2020的一个总结和告别。记得去年写年终总结的时候，对于2020是充满期待的，没想到竟是如此魔幻的一年。新冠疫情对全球造成的冲击，似乎也超出了很多人的想象，记得美国这边刚有确诊的时候，很多人只是觉得这不过是大号流感罢了。说实话，在30岁的这个关口，自己一直默默地在做心理上的建设，似乎是出于对青春的不舍，更是希望自己能够从以前走的路上多多总结思考，为下一个十年的征程做一个好的心理开端。</p>

<p>2020，无数人希望它赶紧过去，再也不见。如今它过去了，这个世界似乎还是那个模样，但我相信很多人的心理上多少还是会宽慰些吧。2020，对于我和我的家人，当然也是非常特殊的一个年份，接下来还是从几个方面简单回顾总结（生活，工作，阅读，投资），并制定一下2021的行动指南。</p>

<!--more-->


<p>2020，是我们在海外完整度过的第二个年份，转眼间来到异国他乡已经两年半了，不得不感叹，岁月如梭，白驹过隙。按照惯例，先对对账，把19年的行动指南搬过来：</p>

<pre><code>0. 多多陪伴家人
1. 坚持每周健身（提高三分球命中率和稳定性）
2. 坚持工作中在视频理解方面的技术积累，注重系统性
3. 培养自己的阅读品味（不追求数量，根据自己的时间安排阅读，多思考）
4. 培养自己的领导力，并在工作，项目上付诸实践
5. 分布式系统方面的阅读和积累，动手实现一些经典算法（比如Paxos）
6. 带老婆和宝宝去一次长途旅行
7. 练习滑雪，可以比较熟练地在蓝道玩耍，有可能就挑战黑道
8. 研究游戏引擎的原理和实现（纯粹是满足好奇心）
9. 参加CVPR 2020
</code></pre>

<p>其实我对于今年的完成度是心里没底的，年底前想起来就翻了翻去年的总结文章，结果自己都吃惊了，貌似还不错呢。看来，立下行动指南还真的挺有用的，不需要刻意地去想，每天盯着，你定了，那么大多数情况下你会跟随内心走，行动不会偏差太多。先说完成的好的，0，3，4，7，其中0完成的最好（疫情原因，有很多的时间可以跟宝宝一起成长，而且父母跟我们难得一起生活了接近一年，仔细想想，从初中住校开始算起，那么多年加起来可能都没有这一年在一块的时间长，哈哈）。3的话，还不错，读完了《毛选》，陆续读了几本好书，又通过其他渠道了解到更多的好书，慢慢形成良性循环了。4呢，就是慢慢来，厚积薄发，戒骄戒躁，稳步提升。7算是超额完成，体验了Stevens Pass的黑道，对于滑雪算是真正入门了。完成较好的，1和2。如果没有疫情，每周健身对于我来说是小菜一碟，然而疫情后健身房关门，打乱了计划。所幸，坚持了篮球，又自己买了瑜伽垫和健身球。三分球真的有提高，这一点我自己也特别开心，练习方法就是跟小伙伴按照轮数练习，每轮投25个，每个点分别5个；买来的装备可以在家里愉快地练习核心力量了，这里需要检讨下，刚买的时候用的很勤快，后来爸妈回国了，一忙起来了就堕落了，21年还是要坚持下去，保持身体健康。那么剩下来的5，6，8，9，就完成得不好了，5的话，其实在读《Designing Data-Intensive Applications》，且非常享受，只是投入还是比较有限，也没有去动手实现算法，自己对于分布式还是有热情，会慢慢花时间去做更多的研究。6由于疫情原因没能成行，希望今年能有机会吧，不过带着宝宝和爸妈在周边转悠也挺好的，对于Mountain Baker印象比较深刻，也是辰辰的第一次雪山之旅。8算是彻底没碰，貌似觉得优先级没有那么高了，被其他事情替掉了（一会细说）。9本来是想线上参加，那阵子情绪不怎么高涨，工作上也在忙，所以就放弃了，现在想想，还是应该参加一下，跟上研究和技术的发展；21年，无论是线上还是线下，都争取参加。那么好了，年度review告一段落。下面，咱们展望一下，2021！</p>

<h2>生活</h2>

<p>2020年的生活，很大的不同是由疫情带来的，在造成不便利的同时，又使得陪伴家人的时间大大增加。记得3月份之前，每天在公司偶尔会打开手机想看一眼宝宝是不是在睡觉（在婴儿床上放了个摄像头），然后下班后就兴冲冲回家想看看宝宝在干嘛。从WFH开始之后，可以说每天都在看着宝宝成长，工作时间，爸妈会带着宝宝出去遛弯，但只要小家伙在家，就会时不时下去看一眼或者陪他玩一会儿，哈哈。另外就是，疫情使得原本计划5月份回国的父母推迟了计划，申请了延期并顺利获批，这样算下来，父母跟我们一起生活了几乎整整一年（差一个星期就满一年）。真的难以想象，就像刚才说的，初中后开始住校，每个周末才回家（父亲出车，很多时候不在家）；高中变成每两周回家一个周末；大学，读研，工作后，基本都是过年回家呆几天而已（不超过一个星期）。这一次父母过来帮忙带娃，一下子在一起生活了一年时间，真的远超之前在一起的时间，最重要的是，每天都会见面，之前回家都是间断的。怎么说呢，在外面生活惯了，难免跟父母有一些理念上的小冲突，不过整体我们过得非常愉快，有小宝宝这个开心果，大家就更加融洽了，只要大家都围绕小孩子转，那么一切问题都不是问题。这里还是要表扬一下老婆，一年的时间，几乎没有跟父母拌过嘴，什么事情都考虑地很周到，大赞！</p>

<p>父母帮忙带娃，工作日的白天我们可以专心工作，晚上我们就多陪陪宝宝。周末的时候就给父母一些休息的时间，不过还是要检讨一下，炉石的战棋模式我真的是疯狂玩了一阵子，那时候周末就沉浸在下棋的快乐和烦恼中，很多时候都没有怎么陪娃，好在后来慢慢回归理性，变回休闲玩家，情况大大好转。不得不说，人是容易依赖的，仗着父母在，真的可以为所欲为（哈哈哈），就觉得说，小孩子丢给你们好了，我就专心当好司机，周末带大家出去玩。而且，而且，洗碗也不需要我了，甚至倒垃圾都不用了，现在回想起来，真的是不太好，做些力所能及的家务还是应该坚持的，不能因为父母在，自己立马就甩手掌柜了（有这种想法的人是不是有很多，举手，哈哈哈！）。</p>

<p>因为父母回国的事情，也稍微烦恼了一小段时间，查机票，预约核酸和抗体检测，心里一直悬着一块石头没有着落。好在后来顺利回去，隔离，回家，一切都按照计划进行。本来计划5月份坐海南航空回国（买的往返机票），后来海航飞不了，就在9月份开始关注新的回国方案，订了加拿大航空的转机方案。无奈，10月底国内有新规，需要提供核酸之外的抗体检测，且有效时间也从72小时缩短到48小时，令人感到十分紧张。新规出台的当天，果断买了达美的直飞，心想说，这时候钱不是问题，父母想回去了才是第一要务。很多人说，这政策分明就是不想让我们回去吗？怎么说呢，咱也要表示理解吧，毕竟抗疫的代价实在太高了，谨慎保护胜利果实没什么毛病。</p>

<p>基本来讲呢，2020年的生活非常特殊（我想疫情可能使得大家都有同感），可以说充实，也可以说重复。我用两个关键词来总结吧：亲情，陪伴。新的一年，希望宝宝继续健康快乐地成长，陪他继续充满好奇心地探索这个世界；也希望家人，朋友们，健康，快乐！</p>

<h2>工作</h2>

<p>2019年，自己在跟老板建立了信任之后一直在加强那份信任，努力输出。2020年呢，信任已经相对牢固，老板也给了我更多的发挥空间，不停地给我创造一些提高的机会。除了做好本职工作外，开始注重培养自己的领导力，关注一个组如何运作，一个org如何协调，通过不断地观察，思考，总结，实践，加强自己的业务能力。说实话，上半年的工作并没有太大的浪花，基本都是之前在做的东西；变化主要发生在下半年，这也是自己觉得比较值得肯定的一点，创造做项目的机会。其实19年底的时候，某个项目负责人就跟我简单聊过，说一个想法是否可行，我简单思索后给出了肯定的答复。几个月过去了，项目的时机相对成熟起来，那个人又来找我说有一些文档，看看能不能给一些反馈，我立刻嗅到了一个很好的项目机会，非常认真地给了自己的想法。随着想法慢慢成形，我们开始两个人的每周讨论，开始做原型。最开始进展顺利，并做了一次比较成功的demo后，项目就正式定下来了。接下来我根据项目需求，慢慢做优化改进，直到最近，产品化的事情进入末段冲刺阶段。回头看，真的非常感谢那个负责人愿意找我讨论，寻求我的见解；也非常感谢自己的老板，给予我工作上那么大的灵活度。目前这个项目的第一阶段接近尾声，过程中对于跨团队合作，沟通，时间点确认，技术问题讨论等都有了新的体会。相信之后的阶段会带给自己更多的提升机会。</p>

<p>工作的主要内容还是围绕视频理解，自己的体会还是涉猎太有限了，对于这个领域还没有一个非常系统以及深入的理解。算法，系统，视频编解码这些领域，都需要慢慢花时间去补充知识点，并自己去融会贯通，灵活运用。</p>

<p>暑假跟一个实习生合作，由于疫情，只能是远程办公，这也给合作带来了一些挑战。按照“设定目标-执行-回顾-改进”的思路，整体的合作非常愉快，既能够让实习生有独立思考的空间，又能够在适当的时候提供必要的讨论。相比于去年的合作，今年不管是在心态上，沟通方式上，都更加游刃有余了。8月份的时候，去年的实习生以正式员工的身份加入了我们组，我真的是非常高兴，自己终于有了做同一个方向的小伙伴了。而且难得的是，我可以给他提供一些有用的建议和帮助，跟他一起成长。从入职至今，项目的进展都非常顺利，非常期待我们新的一年的合作！</p>

<p>2021年，希望继续做出一些有用的工作，在积累技术，培养领导力的同时，更多地跟同事们交流学习。一个人的力量是有限的，而一群人的力量，不可限量。</p>

<h2>阅读</h2>

<p>本来19年给自己定下flag说，读完《毛选》，事实证明，太激进注定失败。也间接让我不再立flag，转而制定行动指南。今年的阅读，品味上升了，但是阅读时间还是比较有限，阅读量也没有达到满意的程度。《毛选》一共四卷，10月份的时候结束第一遍阅读，不得不说，太值得了！很多人听了《毛选》这个名字，就会觉得说，嗯，这种书是给那种坐办公室的人读的吧，跟咱没啥关系。看到读《毛选》的人也会觉得不可思议（我不确定是不是，就是有这种感觉而已）。我从一开始阅读，也是试试看的心态，权当是回顾历史了，从伟人的独特视角来观察。没想到，读到一些精彩的文章，我才意识到《毛选》的哲学思想和思辨，让人欲罢不能。不管说是创业也好，平常工作也罢，就算是老老实实过日子，我觉得读一读都会有收获。阅读的过程中，我有个小小的体会，很多事情真的没那么复杂，不管这万千世界如何变化，本质上的principles就那么些，理解了这些才能抓住事物的本质和重点。书里的几句话，可能会让你感觉到工作生活上的共鸣，带着启发再去实际中去进一步体会，运用，效果很好。</p>

<p>坚持了一段时间的《古文观止》阅读，主要是用手机App（史籍），然后又买了纸质版，因为实在太喜欢了。其实高三的时候，为了加强文学素养（语文多几分），自己就坚持读过一个版本的《古文观止》，可惜走马观花，很多东西还十分地不理解。这次阅读，每每读到一些好文，好句，好的道理，拍案叫绝，并不由自主地分享给朋友们。目前阅读了前三卷的周文，第四卷的战国文，正在阅读第五卷的汉文，翻了下目录，剩下的内容还有不少，2021年继续享受这份阅读的快乐。</p>

<p>还买了一些蒙氏教育的书籍，想多少了解一下这个理念的精髓，大概读了其中一本的前5，6章，就暂停了。目前对于培养孩子，还没有形成比较好的理念，摸索的时间也比较有限，现在就是顺其自然，自由探索。接下来，需要加强这方面的阅读，至少自己心里还有杆秤，对于宝宝的发展有个大概的指导原则。</p>

<p>其他的就主要是技术，管理，领导力，投资方面的书籍了。这里不多赘述了，简单列个书单在这里吧（小部分已经读完第一遍，其他都是今年想读完的）：</p>

<pre><code>0. Designing Data-Intensive Applications
1. Radical Candor
2. Dare to Lead
3. 养育男孩
4. 培养高情商男孩
5. 交易心理分析
6. The Simple Path to Wealth
7. 投资学
8. 期权、期货及其他衍生产品
9. 金融市场技术分析
10. Python金融大数据分析
11. How to Make Money in Stocks: A Winning System in Good Times or Bad
</code></pre>

<p>希望今年至少完成这个列表并切实地有所收获，如果超额完成任务，那将是非常开心的一件事情。</p>

<h2>投资</h2>

<p>记得去年的总结里面提到了，自己一直对于经济如何运作，金融市场怎么回事充满了好奇心，且表示自己不准备去动股票。2020年，情况发生了很大的变化。从我开始认真研究401K，各种退休账户，投资账户，ESPP开始，自己的观点悄悄地发生了变化。意识到手里的钱放着就不停地在贬值这一朴素真理之后，进军股票市场便成了理所应该的事情了。其实我后来读《投资学》意识到，除了股票这种风险资产，也可以去配置债券等无风险资产的。但怎么说呢，谁让“炒股”这个词这么流行，那么多人在讨论买卖股票呢，于是进入金融市场最开始交易的就是股票了。我本来的预期就是抗通胀，入市前想着强烈看好Nvidia，拿了一个小资金开了账户后就买进了（当时我记得是400块左右一股）。当进入市场，稍有盈利就觉得挺好了，慢慢地心态就发生变化了（是的，贪婪是人的本性），导致有那么几天超级关注自己的账户（估计新手朋友们都有过这个经历吧，哈哈），稍微的涨跌心里都会咯噔，而且有时候疯狂地在雅虎财经刷帖子。后来在一只疫苗股上重仓，亏了30%，整个人都不好了（把Nvidia换掉了，囧）。这次亏损让自己的心理发生了一系列的变化，有时候觉得说，唉，亏了，好惨；有时候又想的特别开，亏了是好事呀，刚入市，亏损了可以让你树立好的风险意识，不至于一开始顺风顺水，到了后面胡来，亏个底掉。</p>

<p>事实证明，还是要感谢这次亏损。现在每天听一些财经节目已经成为了我新的日常，最喜欢“视野环球财经”和“雷公的投资频道”，其他的一些财经博主也都会提供很有用的信息和分析（这里暂时不一一列出了）。开始学习如何分析一家公司，如何阅读财报，如何理解消息面的东西，如何止盈止损，如何控制风险。最最最，最重要的是，如何保持良好的心态。《交易心理分析》的作者认为，交易最关键的不是技术，也不是内幕消息，就是心态。技术再好，心态跟不上，也很难成为长期赢家。这里定义一下赢家：一次交易翻了10倍，又在其他交易上亏回去，每年的投资表现上蹿下跳的，不是赢家。赢家是那种洞察市场规律，保持良好心态，每年能够获得稳定收益的投资者。赚一次钱不难，难的是，多次赚钱。</p>

<p>我非常享受进入新的世界，学习新知识，获取新技能的这个过程，不知不觉地，自己的认知也在慢慢进化。通过自己的努力，年底的时候亏损基本上抹平了，2020年不赔不赚，当然这是从资金上来说，从获取知识，探索世界的角度来讲，我赚大了！伴随着疫情，金融市场大水漫灌，我2020年的投资成绩应该是垫底的，不过我仍然觉得，自己开了一个非常好的头。磨练了心态，尤其是亏损承受能力；学习了知识，熟悉了大部分的金融市场用语，能够跟上大多数财经博主的分析；锻炼了技术，自己慢慢形成分析的习惯了，而不是无脑跟风买卖。</p>

<p>整体而言，我把自己定位成一个价值投资者（小资金投机纯属娱乐）。不期望一笔交易带来10倍的回报，而是希望通过自己切切实实的努力，投资能够取得稳定的理性的回报。2021年，继续探索这个新世界，提升自己的投资水平！这里引用一下视野哥Rhino常说的一句话：市场的钱是赚不完的，但本金是可以亏完的。与各位投资朋友们共勉:&ndash;)</p>

<h2>2021 行动指南</h2>

<pre><code>0. 多多陪伴家人
1. 坚持健身和打篮球
2. 坚持阅读，继续提升阅读品味和质量
3. 坚持工作中在视频理解方面的技术积累，注重系统性
4. 培养自己的领导力，并在工作，项目上付诸实践
5. 磨练投资心态，提升投资水平
6. 带老婆和宝宝去一次长途旅行
7. 参加CVPR 2021
</code></pre>

<p>三十了，正式开启下一个黄金十年！与朋友们共勉，希望疫情尽快过去，每个人都健康，快乐！（2020年1月19号，晚上11点58分）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2019的总结和思考]]></title>
    <link href="http://hustcalm.me/blog/2020/01/14/2019de-zong-jie-he-si-kao/"/>
    <updated>2020-01-14T11:10:46-08:00</updated>
    <id>http://hustcalm.me/blog/2020/01/14/2019de-zong-jie-he-si-kao</id>
    <content type="html"><![CDATA[<p>最近痴迷于下棋，不知不觉2020的头半个月就已经溜走了，不写点什么总感觉心里空荡荡的，自己其实已经大概对过去年立的flag了，完成度算是及格吧。对2019还是非常满意的，关键词：充实，感恩，对2020年也是充满了期待！谁让这个数字看起来这么有魔力呢，对吧:&ndash;)</p>

<p>2019年，家里的两件大事，都是由老婆完成的，在这里要给老婆点个大大的赞！宝宝在西雅图最美的季节来到了我们的身边，给我们这个小家带来了无尽的快乐（和缺乏睡眠，哈哈！）；老婆顺利找到了工作，半年的辛勤努力在历经小小的曲折后，也画下了完美的句号！我感觉生活和工作都有着不错的节奏，心里有盼头，继续保持探索这个世界的好奇心和享受这个过程！</p>

<!--more-->


<p>2019整体来说过得挺快，也是我们在海外完整度过的第一个年份，在而立的前一年，自己的心智也变得更加成熟了，简单来说，经历过一些事情，肩上多了一些责任，自然就会有更多的思考和收获。先来对一下账，去年的flag贴过来：</p>

<pre><code>0. 帮老婆找工作，照顾好家庭，多陪家人聊天
1. 阅读至少20本有营养的书，学会如何阅读（硬性指标：读完《毛选》并跟同学讨论）
2. 深入Video Undertanding这个topic，在新项目中落地一些关键技术
3. 坚持每周健身（打篮球）
4. 坚持每周去听技术分享，并努力在某一个话题可以做一次分享
5. 增重到70公斤
6. 学习经济学方面的东西，从万米高空了解最基本的原理
7. 去一次夏威夷
8. 坚持写博客，技术分享+生活感悟
9. 学习分布式系统方面的知识，深入理解大规模系统设计的取舍
</code></pre>

<p>刚才说了，完成度基本合格。0， 2， 3， 5， 7挺好地完成了；1较好地完成了，养成了在早上的班车上看书的习惯；4，9完成度一般；6，8有所思考，但行动不多&hellip;
之后的博客，不准备再立这方面的flag了，文章不凑数，待自己确有值得分享的见地便自然动笔。经济学方面，对整个世界经济的运作原理还是非常好奇，对个人理财需要加强关注，邻居建议我看看股票，我思前想后还是觉得暂时不碰那玩意，不想被牵扯太多精力以及情绪的波动。当然也不能过于保守，每每想起来，老了之后退休了，只能靠养老金度日，便十分惶恐，因此如何寻得躺着挣钱的途径，是一个问题。</p>

<h2>生活</h2>

<p>是的，我想明白了，家人和生活于我，是第一位的。Work life balance非常重要，你可以热爱工作，但不能牺牲生活。2019最大的收获，就是可爱的宝宝，在西雅图最美的季节，最好的月份来到我们身边，感谢上天的恩赐！</p>

<p>之前没有太仔细想过有了宝宝之后的生活，一转眼，发现自己已经成了超级奶爸，从最开始的喜悦，紧张，到越来越的期盼，以及预产期临近的紧张和淡定（真的，邻居劝我在家办公，老婆说没事，你去上班吧，我自己也没觉得多么紧迫，结果就在我犹豫要不要开始在家办公的时候，小家伙着急出来了，哈哈哈）。从最开始的笨手笨脚，到熟练地换尿布，喂奶，哄睡，一切都非常自然。巧的是，邻居家的宝宝比我们家只大了三天（事实上，我们预产期要更早，我在我们宝宝出生的前一天去看了这位小哥哥），这就是命吧，两个小家伙从出生就开始了他们的友谊。</p>

<p>1月份去夏威夷参加AAAI，顺便玩了玩，见到了之前亚研的同事，非常开心。回来之后的一段时间，老婆每天认真准备找工作的东西，我会帮忙做一些模拟面试。不得不说，找工作确实是一个工程，准备简历，检索职位，投递简历，电话沟通，面试，焦急地等待反馈&hellip;
那时候想的挺完美，2月份找到工作，然后趁着签证还有效，回国一趟。实际情况是，回国的这个想法使得老婆颇有压力，自己给自己弄了一个时间限制，增加了不少焦虑，后来果断决定不回国了，专心找工作，这是一个非常明智的决定。老婆的心态也随着每一次面试有一些波动，我既担心，怕太焦虑对她自己和宝宝都不好，又对她很有自信，觉得不能太慌，找工作是一个过程，要学会享受过程，从中学习，最终一定会找到适合自己的工作。我们当时的策略是从小公司开始投简历，增加经验（对的，老婆的口语也需要加强，一度对这个挺担心），然后再投一些大公司的职位。当时也得到了很多朋友的帮助，帮忙投递简历，介绍面试经验，感谢大家！事实上，最后入职的职位就是一个朋友推荐的，且过去后经过一次小的重组，汇报给了同一个老板，我想，这也是缘分吧。印象比较深刻的面试，一个是G家，一个是A家，前一个的面试失败直接影响了后一个的面试心情，有意思的是，就在我们感觉不是特别良好的时候，接到了HR的喜讯，给了offer，且还不错！至此，老婆找工作，画上了一个完美的句号。相信每一个找过工作的人都深有体会，找工作的过程有多煎熬，拿到满意的offer后就有多开心！</p>

<p>老婆找工作告一段落后，接下来的主旋律就是宝宝啦，然后这一年仿佛进入了快进模式。现在还会觉得，仿佛开车去医院就发生在昨天&hellip; 宝宝出生，老婆月子，宝宝喂奶，儿医，看托儿所的介绍并开始排队（嗯，好的需要排一年的队，呵呵），买宝宝用品，之类，之类的，时间，真的如白驹过隙。印象比较深刻的一些时刻，宝宝刚出生，剪脐带；出院第一天，就被我们带到超市；第一个月看着这个小生命，感觉真的好神奇；满月蛋糕；第一次微笑；帮宝宝洗澡；百天照；带宝宝去Deception Pass以及爬Rattle Snake&hellip;
好几次都在想，宝宝如果一直是这么可爱的状态也挺好，哈哈哈！小家伙第三第四个月长得很快，抱起来的感觉都不一样了，慢慢会翻身了，会坐了，感觉越来越可爱了，因为互动更多了，也越来越难带了，有宝宝的人都懂:&ndash;)</p>

<p>2019，开心，感恩。2020，没有太多的期盼，希望家人朋友们健康快乐就好。</p>

<h2>工作</h2>

<p>2018年5月底加入现在的团队，如果说18年是在跟老板和同事建立信任关系的话，那么19年就是在这种信任的基础上非常开心地工作了一年。老板非常支持我的一些想法和个人成长，努力地给我成长的机会，沟通起来也非常地合理，高效。这一年参与的一个大项目慢慢有了起色，从去年的原型，验证，到了产品设计，实现，以及最终的private
preview阶段了（全速前进中），而我从这个过程中一直慢慢观察，体会，有什么疑问和问题就跑去跟别人讨论，有什么担心也直接跟老板反馈，有什么难题，没别的，就是干。这个过程，使得我对自己的职业生涯有了新的认识和体会，最开始入职的时候难免有些急功近利，现在更多的就是顺其自然，认清自己的优势，瞄准问题，享受过程，平静地等待好的结果。</p>

<p>视频理解这个领域，自己之前没有想过要一条路走到黑，不过目前来看，有一些有趣的问题和技术可以探索，因为这个领域，涉及云计算，人工智能，分布式系统，非常综合，具体到某一个子领域，又非常深刻，这使得我非常兴奋。当然了，技术层面上自己还是要稳步积累的，解决日常问题是一方面，自己在技术上要达到更高的造诣，是一个不断打磨的过程。</p>

<p>工作上，还有一个挺重要的体会，就是想清楚做什么，不做什么，比怎么做要更重要。为什么？如果做了不应该做，或者不值得做的事情，即使你做的天花乱坠，也没啥大用；相反，如果定位准确，即使完成度一般，那么也会有比较好的输出。再说了，我不知道自己对多少人说过这句话了，搞计算机，又不是造卫星，造火箭，你日常工作的一些难题基本上都是可以解决的。即使有bug，服务器又不会爆炸，修了就好了。只要找准了方向，总是可以把东西做出来，这不像是在学校里面考试，这道题不会做，那就拿不到分。工作中的问题，灵活度非常大，你发现正面刚不太好使，不如退一步想想变通之策
，没准瞬间就海阔天空了。而且，今天你老板认为非常重要的事情，到了明天，可能会告诉你，暂时不需要做了。所以，我觉得对待工作，要讲究战略和战术，既要努力把握宏观方向和蓝图，弄清楚大家的出发点，自己想想为什么上面会如此做决策和规划；又要谨慎地对待细节，把需要做的事情好好做。与此同时，要培养自己的灵活思维，不要总是死磕，多换位思考，慢慢的你会发现，老板跟你聊天的时候会变得更有意思，你对自己的职业生涯会有更好的认知和规划。</p>

<p>对了，再提一点，有那么几个月，我对职业生涯有一些困惑，然后找了个mentor，级别比我高很多，非常有经验的一个mentor，这里感谢帮助我找mentor的朋友以及我的mentor！发现偶尔一起吃饭聊聊，真的非常有收获，这个mentor还向我推荐一些公司内部的培训，我约了几次career navigation 1:1，发现聊过几次，对于自己在工作上想要什么，以及如何达成会有更加清晰的判断。</p>

<p>我的价值观，一生中很多时间都在工作，因此，我除了要在其中创造价值，更要收获成就感。</p>

<h2>阅读</h2>

<p>嗯，阅读使我成长，其次令我快乐。《毛选》读了一半，不敢说有太多的共鸣，其中某些片段确实会让我停下来仔细想想，更多的是，我回顾了中国的近代史&hellip; 其他的阅读，整体感觉都跟职场相关，以至于读到后来觉得需要增加多样性，当然每一本书，读起来收获都是很大的。比如《Five Levels of Leadership》，读的过程再结合自己的职场经验，非常爽！</p>

<p>19年，基本上是培养起了阅读习惯，接下来，需要慢慢涉猎，培养阅读品味了。我知道，对于有些人来说，读书是一种享受，就好比我喜欢玩游戏，一有时间就想着玩一会，对于喜欢读书的人，我想，他们一有时间就会想着读一会，否则浑身难受。古人云，书中自有黄金屋，书中自有颜如玉，抱着学习成长的态度读书，没什么毛病，但慢慢把读书作为精神食粮，那真是一种高级享受了。</p>

<p>有几位之前北京的同事，沉迷于哲学无法自拔，我觉得非常有意思，这让我想起来小时候书本上的一句话，在知识的海洋里自由地遨游。在学校的时候没体会到这种遨游的快乐，只有题海无边的苦闷（当然，我还有另外一种观点，当时的想法非常简单，作业是写不完的，所以不必太执着，慢慢写，因为写作业就是强化训练，查漏补缺，只要目的达到了，用适合你的方式即可，所以当年高三大家都在做五三的时候，我买了一套无人问津的白皮卷，自己做的不亦乐乎，恕我直言，五三太过于大部头了，事无巨细，重点不突出，非常愚蠢，低效的题海战术&hellip;），反而出了校园，大家都开始快乐地遨游了，这是一件好事。回头想想，如果学校能够培养学生阅读的品味和熏陶遨游的乐趣，那该多好呀！</p>

<p>所以，20年，我希望培养自己的阅读品味，广泛涉猎一下。大体上分为，文学阅读；哲学阅读；技术阅读。具体的读物，根据情况而定。</p>

<h2>游戏</h2>

<p>哎呀，我本来不想加这一条的，但我想明白了，我是真的热爱游戏！从小学开始，小霸王学习机的时代，到初中PC，到之后的掌机，主机，除了本科和研究生期间玩的比较少之外，其他时间都还是玩的挺多的。举例说明，工作后买了PS4，然后很快就把一些巨作全部玩了一遍，神秘海域1-4, 战神3-4，最后的生还者，巫师3&hellip; 还有19年玩的《荒野大镖客》，《蜘蛛侠》，以及买了就吃灰的《辐射76》&hellip;</p>

<p>嗯，最近痴迷的炉石战棋，不得不说，炉石是我玩过的，个人最喜欢的游戏。没办法，太喜欢这个游戏的玩法，以及动画和声音设计了，总之觉得内核非常好，做工很精良，内容挺丰富。经历了一年多的退坑期后，又被战棋模式忽悠回来了&hellip;</p>

<p>然后，黑五的时候买了switch，抱着买了也不玩，不玩又想买，买了就买了吧的心态，偶尔玩玩最新的《超级马里奥》，回味童年的乐趣。是的呀，玩游戏多耽误事呀，但是你开心就好，不是吗？况且游戏作为一种艺术形式，也可以开阔眼界呢。</p>

<h2>2020 行动指南</h2>

<pre><code>0. 多多陪伴家人
1. 坚持每周健身（提高三分球命中率和稳定性）
2. 坚持工作中在视频理解方面的技术积累，注重系统性
3. 培养自己的阅读品味（不追求数量，根据自己的时间安排阅读，多思考）
4. 培养自己的领导力，并在工作，项目上付诸实践
5. 分布式系统方面的阅读和积累，动手实现一些经典算法（比如Paxos）
6. 带老婆和宝宝去一次长途旅行
7. 练习滑雪，可以比较熟练地在蓝道玩耍，有可能就挑战黑道
8. 研究游戏引擎的原理和实现（纯粹是满足好奇心）
9. 参加CVPR 2020
</code></pre>

<p>是的，我不立Flag了，我开始制定行动指南了！过了2020就三十岁啦，为了迎接下一个黄金十年的到来，今年会很忙呀:&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Everything You Need to Know About the CAP Theorem]]></title>
    <link href="http://hustcalm.me/blog/2019/05/18/everything-you-need-to-know-about-the-cap-theorem/"/>
    <updated>2019-05-18T15:38:06-07:00</updated>
    <id>http://hustcalm.me/blog/2019/05/18/everything-you-need-to-know-about-the-cap-theorem</id>
    <content type="html"><![CDATA[<p>CAP? You thoght, what is it all about? Everytime you heard this word from some experienced guys discussing, you told yourself, this got be very complicated. Well, not really&hellip; It&rsquo;s simplier more than what you expected, I tried to figure out what is CAP recently and put everything I went through here for a record (for fun really). Read on&hellip;</p>

<!--more-->


<p>CAP == Consistence + Availability + Partition Tolerent. That&rsquo;s it! So simple! But when you want to understand what it is really talking about under the context of Distributed Systems, it suddenly becomes a mystery. Why is that? In my words, it as a design principle itself is too obvious to give us real practical design guidelines. Brought by Dr Eric Brewer from UC Berkeley in 1998 and offically represented in PODC 2000, I guess it&rsquo;s more like learnings from the systems they built at that time.
Actually the context from the very beginning is distributed shared data, i.e. distributed storage. Why is that? Because computing is easy, stateless. Network is always unreliable (by natural), you can&rsquo;t do much about it. Storage is stateful (obviously) and can be reliable using algorithms despite of unreliable hardware.</p>

<p>Let&#8217; see how to understand CAP fairly. You may have seen some triagles and be bold, hey, take 2 out of 3. Well, not really. When we go from single-node system to distributed computing, partition tolerant is a must-have property. While CAP can&rsquo;t be achived at the same time, you have to trade off between C and A. You want to have a real high availability system, fine, if partition happens, you have to sacrifice Consistency in some degree (and revover Consistency after partition healed). If you
want Consistency all the time, partition will force you sacrifice Availability, you don&rsquo;t want to response with inconsistent data after all.</p>

<p>Note that, Consistency here means <strong>Strong Consistency</strong>, this is very important when you try to understand CAP. Why? eventual consistency can ensure high availability. The consistency models employed highly depends on business scenarios, for serious data, strong consistency has to be enfored. Production systems may have deploy different consistency models to different sub-systems (components).</p>

<p>Gilbert and Lynch from MIT gave a formal proof in 2002 for Brewer&rsquo;s conjecture. Read that paper, you will find, hmm, this is naive. However, I think the contribution here is to model such systems, give the community a common tongue on pushing the area forward and lay a good foundation since then. I can&rsquo;t help to think, for distributed systems, practice seems a lot complicated than theory. Model can be simple while production systems are always complicated and changing.</p>

<p>In 2012, Brewer wrote a new article to talk about CAP and give it some new meaning refelecting 12 years later after further introduced. This article is much more helpful on discussing how to interpret it correctly (and also point how can it be misleading for the 2 out of 3 saying), the new context of CAP as new systems emerge and evolve, how to keep availabilty in the case of partition and recovery strategies when partition heals. It&rsquo;s worhy a reading, the discussions in it are
practical engough (with very solid and convicing examples).</p>

<p>A paper criticizing CAP appeared in 2015, saying CAP is too high-level to give anything useful when one tries to design such systems, partition in real-life is more like latency. The author came up with a new framework, which is more practical-oriented. I didn&rsquo;t read the paper in details, planning to, it&rsquo;s a very good paper on reviewing what is CAP, how it&rsquo;s proved, what are the short comings and how we can step further. Perhaps, this paper alone will just give you enough context of
CAP, don&rsquo;t bother for other readings.</p>

<p>I assemble a slides and put it <a href="https://drive.google.com/file/d/1c6_bZFSRXILkcYWaNSo7ICNsrKH_o4Mf/view?usp=sharing">here</a>.</p>

<p>Moving forward, I will take a look at Lamport Clocks, Paxos, Raft, etc. So much fun:&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2018的总结和思考]]></title>
    <link href="http://hustcalm.me/blog/2019/01/01/2018de-zong-jie-he-si-kao/"/>
    <updated>2019-01-01T10:16:31-08:00</updated>
    <id>http://hustcalm.me/blog/2019/01/01/2018de-zong-jie-he-si-kao</id>
    <content type="html"><![CDATA[<p>刷着朋友圈，在朋友们跨年的喜悦中，我才意识到，2018年真的已经远去，谈不上太多的不舍，但跳动的思绪需要一点梳理，故作此文。2018是我生命中最重要的年份之一，做了一些重要的决定，并有了一些重要的感悟。</p>

<p>记得从2015还是2016开始，每年的元旦都会在小本本上写上新的一年要做的10件事，本来刚才想翻一下小本本对对账，无奈发现没带在身边，也罢，仔细想想，完成度还是非常喜人的，给自己点个赞！</p>

<!--more-->


<p>我的2018可以大致分为上下两个半场，中间重要的分水岭就是5月底来了美国，正好上下半场时间相抵。上半场基本上是忙着工作，准备出国手续；下半场就是忙着安顿下来，适应美国的生活，结交新的朋友，打造新的工作和生活节奏。这其中不乏一些迷惘，痛苦，纠结，喜悦，希望，憧憬。这里面我悟到的最重要的一点是，追随你心，一旦你认定了一件事情，你总是会慢慢向其进发，既然认定了，就不要过多犹豫，做自己想做的就是了，因为没有人比你自己更懂得自己想要些什么。整体来说，2018在感官上过得还是挺快的，上下半场忙忙碌碌，就到了现在坐在这里写这篇文章。接下来，我挑几个关键词简单展开一下自己的总结和思考。</p>

<h2>投资</h2>

<p>第一个词，从“投资”开始。这个投资不但是指经济上的投资，我在这里想表述三层意思。</p>

<h3>时间投资</h3>

<p>没错，我认为一个人最重要的投资就是“时间”，没有之一！虽说自己尚处于身强力壮的年纪，却每每把“人生苦短”挂在嘴边了，因为我自己真真切切的感受到，人生能有几回搏，再具体来说，人生能有几个十年？且，每个十年又各具其特色，不一样的十年有不一样的任务，目标和各自的精彩。我慢慢开始体会三十而立，四十不惑，五十知天命的用意了，想要做的事情太多，而时间对于每个人，每天就是那么1440分钟，不多不少。如果说这个世界上还有什么事情是公平的话，我想，时间和生死排前两位，生死可能会由未来科技改变，时间也可能会相应地被影响，不过让我们缩小一下尺度，单看一个人的前50年，如果来一个倒计时，我想在可支配方面，人人平等（涉及出身等其他因素暂不考虑）。</p>

<p>不妨让我们简单回顾一下一个人一辈子大抵的时间花销：按照正常睡眠来算，大概三分之一的时间都在休息（或者梦游）；如果至少念完大学，那么人生的前20年左右都在跟学校，书本，考试，同学打交道（好怀念自己7岁之前那段放羊的时光，哈哈！）；毕业之后，找工作，要花大把时间跟项目，老板，同事打交道；结婚生子，又要花不少时间照顾家庭；剩下的可供支配的时间可能但不限于，打游戏，看书，旅游，陪伴父母，跟朋友聊天，写论文，网上冲浪，看电影，发呆，等等。不仔细想，感觉自己的时间真是犹如汪洋大海取之不尽，但简单计算却发现在某些事务上自己可支配的时间少得可怜，拿陪伴父母来说吧，有不少文章精细计算过，一个人一辈子真正陪在父母身边的时间，少得可怜。</p>

<p>回到我的感悟本身，用“有限”的时间去做自己想做的“无限”的事情！废话不多说，就是赶紧明确自己想做什么，想体验什么，然后去做，不要陷入“明日复明日，明日何其多”的陷阱。所以，少一些纠结，多一些行动，尽量挣脱外界的束缚，对自己好一点！具体到时间上，最好有一个相对明确的预算，来投资自己的时间，因为，就跟其他投资一样，有些时间投资可以让你得到十分丰硕的回报，而有些时间投资处理不当则是浪费。</p>

<p>回报：时间投资的回报因人而异，非常丰富，最本质的体现可能是内心极大的获得感，满足感和成就感，通俗点说就是“嗯，时间没有白费！”。</p>

<p>（我在这里稍微多说一句，对于“学英语”这个事情的看法，话说学以致用，如果说没有太想好自己学了之后什么时候用，那不如把这些时间转化一下，比如说看一些好的书籍，我想收获可能会更大。）</p>

<h3>情感投资</h3>

<p>这是今年被我具化了的一个感悟，可能之前一直有这方面的思考，都没有太想好怎么去表达（可怜虫，读书少）。人是社会型动物，社交是必不可少的，而社交必然会产生很多感情投入，而这些感情投入，我现在称之为“情感投资”。最典型纯粹的情感投资我个人认为是父母的爱，不计回报，始终如一。从社会关系来看，常见的有同学，同事，战友，朋友，朋友的朋友，等等。</p>

<p>情感投资，由每个人的性格决定，且具有一定的随机性。我简单来概括，就是“气场”和“眼缘”，“一见钟情”的事情我觉得很正常，“话不投机半句多”的事情同样很正常。一般外向型人格频谱稍宽，更容易跟其他人“聊得来”，而性格相对内向的人在初始阶段会表现出“一定的挑剔性”。情感投资非常复杂，通常不易被人关注，却常常困扰每一个人。通常的表现是，人类希望在情感上被平等对待，像什么“热脸贴了冷屁股”的事情最为不被人接受。然而现实情况是，每个人社交喜好有差异，任何两个人都有选择的权利，大家一开始都会有一个磨合期，是继续深入发展，还是点到为止，不必强求。若强求，必然引来不少不必要的烦恼，得不偿失，这就是一笔失败的“情感投资”了。</p>

<p>情感投资这个词本身可能不怎么招人待见，不过一个人的情感也是有限的，经不起肆意的挥霍。宽以待人，严于律己，坦诚地对待每一个人是比较好的一个指导方针。在这方面，切忌过多揣测他人心思，庸人自扰。</p>

<p>回报：融洽的人际关系，轻松愉悦的心情，一个好汉三个帮的办事效率，可遇不可求的知心挚友。</p>

<h3>金钱投资</h3>

<p>这可能是大家普遍意义上谈论的“投资”，毕竟，没钱是万万不能的。可惜我在这方面比较愚钝，曾经被搞投资的朋友点化过，买了不少书准备开搞，但迟迟未能入坑，没办法，心境未到吧。所以这一方面就不多说了，2019年应该会在这方面有些实际的修炼和提高，解答自己心中困惑的同时，看看能不能有些实际的收获:&ndash;)</p>

<p>回报：你可能血本无归；你可能会有很多钱，很多很多钱。</p>

<h2>生活</h2>

<p>生活不止眼前的苟且，还有“行万里路”和“读万卷书”，这就是我对“诗”和“远方”的理解。2018，生活上最大的变动就是带着老婆来美国了，感受到了西雅图生机勃勃的夏，五颜六色的秋，天气变幻的冬。从北京到西雅图，这个变化是巨大的，也必定是我们人生路上最重要的变化之一。谈不上太多的好坏，适应了新的生活后，我们至少更喜欢现在的生活节奏。</p>

<p>在国内种种的想象，还是多少受到了一些冲击，好在都在可控范围之内。买了房子，车子，背上了贷款，更加体会劳动人民之不易了。告别了地铁，适应了半小时车程方圆50里。告别了回龙观的繁华，更加确定自己更喜欢安静。告别了工作日一日三餐吃食堂，习惯了中午带饭。告别了有些让我窒息的高楼大厦，喜欢这里的低层建筑，一眼可以望到好远。</p>

<p>最不想告别的，当然是北京的朋友，同学，同事和亲人们。但我相信，只要生活还在继续，海内存知己，天涯若比邻！当然，在这边也结交了不少新的同事，朋友，正好印证了我最喜欢的那句诗，莫愁前路无知己，天下谁人不识君！现在已经略有感觉，未来合作的机会很多:&ndash;)</p>

<p>游戏上有了一点新的探索，《炉石传说》正式晋级休闲玩家，尝试了一下《昆特牌》和《MTG》，却已无法激起太大的热情了。《荒野大镖客2》惊喜满满，周末偶尔在西部游荡一下感觉很是满足:&ndash;)</p>

<h2>工作</h2>

<p>现在感觉工作上有难以抑制的热情，每天去上班都是动力满满的，很多人说，“唉，去美国干吗，去那里养老有什么好的？”。没办法，可能还是自己境界不够吧，在一个“养老”的地方也能干得这么起劲:&ndash;) 我反复思考过这个问题，这个转变究竟是如何发生的？结果很简单，搞清楚要解决的问题，加上主人翁意识，对工作上成就感的满怀期待！现在还在不停的摸索中，试图搞清楚我们小组，还有大组，究竟都解决了哪些客户的哪些问题，用了哪些技术和架构，这个行业的趋势和竞争格局如何，未来的需求和热点又会是在哪里。</p>

<p>我不否认这边的工作节奏相较于国内是要“慢一些”，跟996以及更初期创业公司的节奏简直没法比。但凡事都有两面性，这一点我可能存在“自欺欺人”的成分，也没有完全想明白，至少于我个人来说，我期望清清楚楚做事，明明白白奋斗，能够在一个更高的层面思考一些问题，哪里能有这样的环境，那就好好抓住，磨练自己，跟整个组织一起成长。我可能错过了一些机会，但我相信，自己终会给自己机会:&ndash;)</p>

<p>2018，工作上变化相对缓和，还是在折腾深度学习，视频理解，功力尚浅，还在不断的探索，希望能够通过落地实用的系统，让自己能够在技术，商业，领导力方面都得到实际的提升。2019，进一步明确问题，分解问题，解决问题，不浪费自己的时间，对得住老板和工友的信任，一起打怪升级！</p>

<h2>阅读</h2>

<p>假装喜欢“读书”这么多年了，终于在2018的下半年正式入坑了。欠了不少“阅读”债，不过转念一想，自己在读书方面确实还是小学生，之前读过的要么是技术书籍，有么就是偶尔抽风读的畅销书，全然没有自己的脉络和体系。所以，现在特别开心，感觉阅读这个坑可以填一辈子，哈哈！2018，也就读了《Mastering Bitcoin》，《清教徒的礼物》，《人类简史》，《从0到1》，在读的有《支付战争》，《毛选》，《Crucial
Conversations》。2019年小目标，通过阅读自己感兴趣的书，学习如何阅读，所以可能这一年先做一年杂食动物，多多尝试一下，明确一下自己阅读的兴趣和脉络，争取可以在年底有一个自己的推荐书单，给他人一些启发。</p>

<h2>2019 Flag</h2>

<pre><code>0. 帮老婆找工作，照顾好家庭，多陪家人聊天
1. 阅读至少20本有营养的书，学会如何阅读（硬性指标：读完《毛选》并跟同学讨论）
2. 深入Video Undertanding这个topic，在新项目中落地一些关键技术
3. 坚持每周健身（打篮球）
4. 坚持每周去听技术分享，并努力在某一个话题可以做一次分享
5. 增重到70公斤
6. 学习经济学方面的东西，从万米高空了解最基本的原理
7. 去一次夏威夷
8. 坚持写博客，技术分享+生活感悟
9. 学习分布式系统方面的知识，深入理解大规模系统设计的取舍
</code></pre>

<p>2019，保持住心动，多一些行动！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[西雅图初体验]]></title>
    <link href="http://hustcalm.me/blog/2018/10/26/xi-ya-tu-chu-ti-yan/"/>
    <updated>2018-10-26T22:07:35-07:00</updated>
    <id>http://hustcalm.me/blog/2018/10/26/xi-ya-tu-chu-ti-yan</id>
    <content type="html"><![CDATA[<p>时间如白驹过隙，转眼已经在西雅图呆了快5个月了。现在已经基本稳定下来，抒发一点小小的感想。整体来说，对于西雅图和微软总部的观感还是很积极的:&ndash;)</p>

<p>虽然2010年暑假就来过一次美国（在位于印第安纳州的一个小镇Terre Haute上的Rose-Hulman Institute of Technology呆了2周，后来花了半周跟小伙伴们一起体验了一下芝加哥），2017年也来微软总部短暂出差一周，这一次过来难免再次感受到强烈的文化冲击。毕竟在国内呆了那么多年，衣食住行，生活习惯，社会节奏都需要进行不同程度的适应，语言关是必须要过的，否则真是难受香菇。这一次也不准备有条理地写，思路稍微意识流一些，想到哪里写到哪里吧。</p>

<!--more-->


<p>Seattle这个名字在美国我觉得好像远不如New York，LA，Chicago来得响亮，跟国际化大都市不怎么沾边。一提到西雅图，映入脑海的好像就是“波音总部”，“星巴克总部”，“微软总部”，“亚马逊总部”这些名号。也会有人联想到《西雅图不眠夜》，在国内比较火的《北京遇上西雅图》。NBA球迷会想到“超音速队”，可惜几年前搬到了鹅城了。旅游达人第一印象想必就是“太空针”，“派克市场”，Mountain Rainier等等。</p>

<p>固然地标性建筑是一个城市的标配，也是一个城市的符号。而这两年让西雅图声名鹊起的貌似是那疯涨的房价，连续18个月全美增长率第一，确实是让人不得不关注起这个之前没那么起眼的城市。不过仔细分析一下，会发现不停有人口流入西雅图（比如作者本人），是推升房价的一个重要因素之一。西雅图作为美国硅谷之外的另一个IT中心，吸引了大量的IT人才，包括美国东海岸，硅谷，世界各地（印度，中国为主）。不夸张得讲，其作为世界云都的称号真不是盖的，有亚麻和微软两个云计算大厂，全球90%的市场份额被这两个巨头瓜分（我跟科比合砍81分，我才不在乎自己砍多少，O(∩_∩)O哈哈~）。又鉴于目前云计算市场的急剧增长，需要大量人力来支撑业务，人口流入也在情理之中了。有了人口就有衣食住行各方面的需求，经济也就更有活力，以软件行业作为支柱产业，配套各种服务行业。</p>

<p>西雅图的雨也是被大家熟知的一个点，一场雨下半年。全年基本上一半晴天，一半雨天。一般头年10月底到次年的4月底是雨季，写这篇文章正值雨季就要到来。这里，我要赞美一下西雅图的夏天和秋天，秋天真的是极美的，夏天也没那么热（很少有人家装空调，最热的时候吹个风扇，大概两周左右）。从五月底过来到现在，5个月的时间，对西雅图或多或少有了一些自己的认知，接下来重点从我的角度谈一下&mdash;西雅图初体验。</p>

<p>因为在国内的时候也主要是在北京有过一点点生活（不知道算不算），因此下面多少夹带的一些对比也就具有一些局限性。自己作为一个IT从业者，也只能从这个视角粗浅地谈一谈。好山好水的形容很贴切，当我们说西雅图的时候，我们可能只是说这个城市本身，然后西雅图地区可远比一个城市大多了。亚麻总部在Seattle downtown，微软总部在Redmond，隔湖相望，一个在湖西，一个在湖东。如果一个哥们告诉你说他在西雅图工作，他的公司不一定在Seattle
downtown，可能在Redmond，也可能在Bellevue。就拿微软来说，主园区是在Redmond，但同时又有很多的分园区，通过shuttle提供员工通勤，比如在Bellevue downtown的Lincoln Square，在Bellevue College旁边的Advanta（刚过来就先在那里呆了3个月，reorg回了主园区）。这里不讲地理，大概提一下西雅图周边，往西三个小时车程到太平洋，往北三个小时到加拿大的温哥华，往南三个小时到波特兰，往东，往东还没去过&hellip;
一些比较常听说的City就是Seattle, Redmond, Bellevue, Kirkland, Edmonds, Lynnwood, Bothell, etc. County的话可能会看到King County，Snohomish County之类的。亚麻和微软之间是Lake Washington (华盛顿湖)，是一个很大的湖。微软东边有一个相对相对较小的湖叫Lake Sammamish (翻译过来有人叫做色眯眯湖, orz)。 微软的员工大都住在Redmond, Bellevue, Kirkland, Issaquah, Sammamish这些地方，比较后来的遇到房价飞涨，只能北上到Lynwood，Bothell。我不太确定是不是大多有钱人都在Mercer Island住。</p>

<p>西雅图的要道主要有I5，穿过Seattle downtown，往北可以到温哥华，往南貌似可以一直到墨西哥。405，主要是南起Renton，北至Everett，以堵车而著名，号称没有不赌的时候，事实也确实如此，走express lane会稍微缓解情绪，只是要花钱。以上两条是南北方向，东西走向的要道有90，520，都有桥横跨Lake Washington，还有522。东西的路都连接了I5和405。</p>

<p>简单说一下微软的通勤选项吧，公司在不同的campus之间以及不同building之间都提供了shuttle，前台有专门的设备可以预约；还有不少Connector，就是大巴，每天上午下午辐射到整个西雅图地区，根据人口分布班数也不同。一般可以开车几分钟到一个Connector站点，然后乘坐Connector，即省得自己开车闹情绪，还可以省些油钱。这一段时间的感受，通勤时间上来回坐班车的话加起来在一个半小时左右，可能由于在车上读书的缘故，觉得时间过得挺快。有人选择住在公司附近走路5-10分钟的地方，通勤成本就更低了。非繁忙时段，15英里的路程大概开车20分钟，这个效率还是可以接受的。稍微吐槽一下Seattle downtown的交通吧，虽然一共也就去过那么两三次，停车真是太难了。</p>

<p>这边的房子有House，Condo，Apartment之分，直观点说分别是独立屋“别墅”，联体别墅，公寓。80w美金的房子如果首付20%，外加其他的花销，20w预算可以拿下，按照这边毕业生的工资水平，5年可以攒够首付？不过每个人想法不一样，美国人的购房观念貌似没那么重，号称一个美国人一辈子平均在十几个城市生活，不知道是不是说法有点夸张，不过跟组里的同事聊，两个刚毕业的美国小哥，他们确实没有这方面的想法。这个话题略去不表了。</p>

<p>西雅图可以玩的地方不少，著名的Mountain Rainier和Olympic Park是夏季打卡神地，还有无数的trail可以开发探索。这个夏天貌似也就驱车去湖边看日落，打卡Rainier和Olympic，再就是好天气去hiking，整体体验很赞。</p>

<p>饮食上目前华人的选择很多，中餐馆都有分布，味道上虽不如国内地道，但能吃到就已经很满足了:&ndash;) 最最重要的是，华人超市提供的商品也是应有尽有，不会在生活的适应上有太多不适感。</p>

<p>衣食住行+娱乐，工作上就不多说了，我觉得节奏还是可以的，如果想做事情，可以静下来细细地做，雨季的周末宅在家里看看书也是不错的选择。断断续续写了这么多，一是想念自己写文字的感觉了，二来小小抒发一下。雨季来了，希望自己能够静心读书，在工作上能够更进一步，不断扩展未知的边界，共勉:&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[近况杂谈]]></title>
    <link href="http://hustcalm.me/blog/2018/06/13/jin-kuang-za-tan/"/>
    <updated>2018-06-13T21:41:04-07:00</updated>
    <id>http://hustcalm.me/blog/2018/06/13/jin-kuang-za-tan</id>
    <content type="html"><![CDATA[<p>真的是好久不写博客了，时间都去哪了？我现在越来越觉得相对论颇有道理，不说物理学上的，而是生活中的。记得本科快要毕业的时候，自豪地说，没觉得本科过得那么快，可能是觉得比较充实，说得通俗点，就是用一些事情把自己的时间支撑起来了，没有虚度。读研的时候也算是兢兢业业，努力上进，略留遗憾（是说要读PhD吗？）工作以来觉得时间过得越发地快了，究其原因，由俭入奢易啊。工作上算是正常节奏吧，游戏上花了一些时间（PS4大作，炉石），其他感觉就是琐碎一些，没有想着在某一个东西上沉淀（所以博客也晒网了，罪过）。</p>

<p>今天呢，主要聊一聊近况，算是自我的一点抒发，顺便捋一捋自己的方向。</p>

<!--more-->


<p>不忘初心真的挺难的，好比学生时代的各种美好畅想，会被工作之后的物质压力慢慢冲淡，一种强烈的逃离感和略微的绝望感。你会问自己，社会究竟长什么样子？学校里面学习好，就什么都好。为什么学习成绩第一的人到了社会也就泯为众人了呢？当然，这里的泯为众人，实则是由理想主义转到现实主义，尤其是组建家庭后，大家都想要有一个自己的家（房子）。你可能挣着“看起来”还不错的工资，但算一算发现并不能太舒服地在某一个城市立足，自己想要的生活可能也无法实现。瞬间（或者说慢慢的），你的世界观开始发生重塑。哎？这个东西不是这样的吗？咦？跟我想的不一样啊。用崩塌也不为过吧，你会发现按部就班没什么不好的，但是也没什么好的。人是社会性动物，多少会受到周围环境的影响和干扰（情绪上）。这个时候你会问自己，我是谁？我在哪？我要干什么？</p>

<p>上面过于放飞思维了，收一收，谈回近况。在北京读了三年研究生，工作了两年零十个多月，跑来了西雅图，算是实现了自己出来看一看的想法。游戏上除了初中开始痴迷的梦幻西游，工作后玩了大概一年的PS4（大作基本玩了一遍），然后出现了人生中最喜欢的游戏之一，炉石传说，打了一年多一点，到了月常传说的水平（狂野）。计算机视觉出身，一直不愿意放弃，只能在工作上尽可能地去靠近，来了美国后感觉又偏离了一些，这是接下来需要改进的。在国内的时候出现过多次思维碰撞，被AI浪潮弄得一愣一愣的。有过一些工作机会，都只能暂时say no。</p>

<p>一直以来的信条就是，人生即体验。每每想起这个，感觉整个人都更好了，想想接下来的房贷车贷，整个人又沉重一些。围城，深有体会，在适应期更会去做这一方面的思考。我个人还是偏乐观和理想主义的，想按照自己的想法去安排自己的生活（时间），觉得这个世界总会有自己的立足之地。也曾内心汹涌，激情澎湃，动不动就想扑进创业的浪潮。工作后冷静了很多，发现，哎呀呀，这事情比自己想象的，复杂好多啊！有一种很广为流传的说法，做一个大公司的螺丝钉有什么意思？你如果有惊天动地之才，请不要浪费；如果还没有，不妨观察观察，修炼修炼。成功的方法其实不多，失败的方法则五花八门。（幸福的人&hellip;而不幸的人&hellip;）</p>

<p>我还是要坚持内心的想法的，很简单，你想做什么？怎么做？需求层次什么的，不扯那么多了，好与坏，冷暖自知。前途还是十分光明的，让我们微笑前进:&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工作后的一点感悟]]></title>
    <link href="http://hustcalm.me/blog/2016/07/22/gong-zuo-hou-de-yi-dian-gan-wu/"/>
    <updated>2016-07-22T09:19:26-07:00</updated>
    <id>http://hustcalm.me/blog/2016/07/22/gong-zuo-hou-de-yi-dian-gan-wu</id>
    <content type="html"><![CDATA[<p>转眼参加工作已经整一年了。这一年渐渐感受到作为一个社会人与学生时代的不同，离开象牙塔才逐渐有了心慌的感觉，以前很多下不定决心做的事情，在压力和自我追求的权衡中慢慢变得很容易坚定去做了。做了18年的学生（真是应了18年寒穿苦读的老话），走上工作岗位，踏上社会，心里是有莫名的解脱感的，可能自己确实想去探寻一下科技公司究竟都在做什么，且是近距离的观察➕亲身体会。一年的时间不长不短，略微有一点思考和感悟。</p>

<!--more-->


<h2>学生思维</h2>

<p>从学生时代走向工作岗位，思维方式需要有一个转变，这是大多数应届毕业生都会面对的（尤其是在正式参加工作前没有实习经历的同学们）。学生思维具体体现在：产品意识不够强烈，如何站在老板的角度思考问题，动态的眼光看待外界环境。</p>

<p>大家都知道，学生做项目基本是“可用，可运行”为主，受众也通常是自己或者实验室的同门，如果对自己比较自信又富有分享精神，开源社区的可能也是受众。质量保证是“学生项目”和“公司项目”根本的不同之一（我目前是这么认为的），一次产品的发布需要从需求分析开始，到需求明确，时间表制定，开发，peer review，测试（这是学生比较容易忽略的，测试用例的设计以及测试的执行是很重要的能力），dog food（相当于内部beta一下），bug
fix，测试报告等文档，最后到release review（一些你之前根本不会考虑的问题，虽然不难，但做的时候多少会让你明白，原来发布一个小的算法都要做如此繁琐的review工作啊），才“有可能”顺利发布。发布后还没有大功告成，维护，更新，修bug，都是分内之事。</p>

<p>本科阶段“混”毕业，研究生阶段“求”毕业。相信读研的同学们多少有点跟老板“斗争”的经历，毕业如一座大山，你想出去实习，老板想你做实验室的工作，不一致的目标导致冲突。作为过来人，反思一下，谁都没有错，站在不同的角度思考问题，老板是很有道理的，这个时候只能看如何跟老板沟通。进了公司，类似的情况肯定也会时有发生，和老板就一些问题意见不一致。不过退一万步讲，如果没有到那种你做的工作一点都不敢兴趣的地步（否则你早就离开了），我的体会是尽可能多地从老板的角度想一下问题。为什么？老板带领团队肯定是想做出东西来，整个团队的大目标是一致的，老板肯定希望团队能够健康快速平稳地发展，每个人都能够有所收获（个人能力以及福利待遇），他看问题和我们看问题的角度肯定不一样，他的很多做法我相信肯定有他的道理和相应的支撑。所以，出现了不一致怎么办？找老板沟通，就一些具体的问题讨论，有效地把一些看法讲清楚，本着大目标一致的原则，寻找共赢。（第一年，我的体会是少一些个性发挥，多一些踏实出活，多观察多干活，少说话，该说的一定说，没把握的或者太天马行空的再酝酿一下）。</p>

<p>让我们回想一下，学生时代每个人都属于一个班级，然后在求学的某一个阶段，同学关系相对稳定（很少有同学随意到别的班级去了，当然有转校的，但是这种情况非常少），也就是说，你的外界环境相对少变化。工作之后，情况会变得完全不同，每个人都会有自己的职业发展轨迹和想法，你入职的第一天就可能会看到身边即将成为同事的哥们正在收拾东西准备下一段旅程了。时不时地，你会收到一些邮件说“Today is my last working at&hellip;” 或者“Friday will be my last working day&hellip; let&rsquo;s have lunch
together”，一开始你可能会觉得不理解甚至惊愕，咋回事？在这工作不是挺好的吗？昨天还跟大家谈笑风生的同事，也许今天就是共事的最后一天，学生时代毕业的日期可以预期，身边的同事谁会下一个离开没有预期。接受它，这就是工作和市场，人才流动是行业发展和个人发展的必然。</p>

<h2>想做的和该做的</h2>

<p>这个其实是想说如何把自己的目标和兴趣，跟团队和老板的整体目标尽量地align起来。Work what you like, like what you
work！需要搞明白的是，来公司工作是为了创造价值的，虽然说成“给老板打工“有些欠妥当，但试想一下，如果你是老板，你喜欢什么样的员工？我的答案是，主动努力地去解决老板的问题，为什么？老板的问题通常就是项目如何往前推进，如何解决项目里面的一些难题，解决这些问题就是在帮老板解决问题，就是这么简单。我觉得，这是该做的。扩展一点，不满足于完成自己被分配的工作，主动去承担问题解决的责任，从项目大的scope多一些思考并时常跟老板沟通（随时去办公室或者利用1:1 meeting的机会），这是一个良性的互动，你会收获很多。</p>

<p>有时候很多工作的人会抱怨，“唉，我做的工作很没意思，我其实想去做&hellip;”，这是想做的。这里可以分两方面解读这个想法。一，确实对某一个技术领域感兴趣，想去探索。没问题，做好本职工作，你会有时间的。或者，尽可能去把自己的兴趣和做的项目align起来，这个要看机会，如果工作上暂时没有好的机会，去开源社区发挥自己的光和热也是很好的选择嘛。没有人能抑制你的兴趣，所以这个方面问题不大。二，好高骛远型的，一边说着手头的工作无趣，却不能把工作做到得心应手，这就是一个非常危险的想法了，这只会导致消极的工作态度，随之而来的是差的工作绩效（然后，你可以再发挥想象力了&hellip;）。我的观点，任何工作，当你做出成绩的时候，成就感本身就是乐趣。So,
do it, do it greatly!</p>

<h2>丛林法则和市场决定价值</h2>

<p>在工作岗位上，合作和竞争是并存的（学生时代不也是如此吗），且比学生时代来的强烈不少。不管愿不愿意承认，职场犹如一个丛林，优胜劣汰无时无刻不在上演。初入职场，没啥体会，随着对职业发展路线的了解以及对所在工作环境的分析，丛林法则的想法会自己钻到你的脑子里。Be nice to everybody is not important, the most important thing is, get your job done, greatly and gracefully. Never be afraid to fail, always try to solve problems. Run, with the sense of crisis.
你必须向前跑，且快速地跑，竞争是无情的（说的略夸张，可这就是事实不是吗）。</p>

<p>市场不尊重传统，它只尊重创新。职场丛林里面的人展开残酷的市场竞争，用创新去颠覆，去开拓，去“屠杀”。当你按部就班的工作没什么波澜的时候，思考一下，你正在平庸的路上越走越远（享受生活不代表平庸，不代表就可以安于现状不努力）。反思一下，我的价值在哪里？几何？市场需要的价值是什么？相信我，你的生活不会因此变得无趣，充满了工作而丧失了生活情趣。你的市场价值的提升会带给你也许任何都给不了你的进步感和成就感，然后你的世界会更加开阔:&ndash;)</p>

<p>（决没有任何强推价值观的想法，看到本文的人权当看看热闹就好：）发现自己工作后变懒了，博客过了一年没更新了，罪恶感上升啊，这一篇文章也给我拖了一个季度了，hustcalm于2016-11-12 12:52:24)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Something About SSE and Beyond]]></title>
    <link href="http://hustcalm.me/blog/2015/12/11/something-about-sse-and-beyond/"/>
    <updated>2015-12-11T19:15:30-08:00</updated>
    <id>http://hustcalm.me/blog/2015/12/11/something-about-sse-and-beyond</id>
    <content type="html"><![CDATA[<p>We happen to know CPU is the core worker of every single computer, however, not everybody cares much about the instruction set architecture. I&rsquo;m quite interested messing up with all these stuff and by taking the brownbag chance of my group, I give a somehow preliminary talk on SSE.</p>

<!--more-->


<p>Everything starts with SIMD (Single Instruction Multiple Data) before we talk about SSE (Streaming SIMD Extensions). It&rsquo;s kind of parallezation technique on data level utilized by hareware (here processor). Dedicated to boost multimedia applications, like image processing, specch related algorithm, etc. SSE on Intel CPUs, as it evloves, we have AVX (Advanded Vector Extensions) now. Also, we have NEON on ARM.</p>

<p>If you happen also have interest, you may refer to my slides <a href="http://www.slideshare.net/calmli/something-about-sse-and-beyond">Something about SSE and beyond</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[找工作的一点经验和教训]]></title>
    <link href="http://hustcalm.me/blog/2015/12/11/zhao-gong-zuo-de-yi-dian-jing-yan-he-jiao-xun/"/>
    <updated>2015-12-11T19:14:31-08:00</updated>
    <id>http://hustcalm.me/blog/2015/12/11/zhao-gong-zuo-de-yi-dian-jing-yan-he-jiao-xun</id>
    <content type="html"><![CDATA[<p>转眼参加工作已经四个月又半了，虽然也还算是初入茅庐的小菜，不过也有自己的一些思考，结合之前找工作的经历，在这里简单谈一些“经验和教训”吧。</p>

<p>找工作还是得突出在“找”上，且大多数情况下是人“找”工作，极少数的情况下会出现工作“找”你（这里我们不考虑猎头社招之类的，特指校招）。首先可以明确的，找工作的时候其实就是匹配你的skill和工作内容的匹配程度，以及你的品性和未来同事的匹配程度，明确了这一点其实准备起来还是可以非常有针对性的。不要太考虑自己的专业背景，专业院校，“英雄不问出处”，问一下自己，想做什么样的工作，哪些公司自己想去，他们需要什么样的人，需要具备怎么样的技能，我目前水平怎么样，匹配程度如何，如果想顺利去这些地方工作，应该怎么做，是不是需要有一个计划，具体又如何实施，如果这一系列的问题你都可以回答自己，或者通过跟他人讨论得出相对明确的答案，那么恭喜你！找工作你已经成功了一半了！</p>

<!--more-->


<p>拿我个人举例，本科读的是机械工程，无奈真的对这个学科提不起兴趣，个人觉得计算机科学真的很有魔力！在ACM集训队经过半年不成功的尝试后，加入学生团队向周围相关专业的人学习，通过实际的项目学习。兴趣导向，基本上确定了未来一定是进入IT行业了。不管是进公司也好，还是创业也好，甚至读个PhD出来，我几乎从来没有对未来想要进入的行业怀疑过。这里的IT，我想说是“信息行业”，不特指软件行业。根据个人经历，可以印证“功夫不负有心人”这句话，中间有大量的迷茫，彷徨，不知所措，痛苦，可正是在这些阶段，是自己飞速成长的时候。真正进入研究生阶段后，才算是转来了一个“跟计算机严重相关”的专业，也是从研究生阶段开始，通过对开源的学习和交流，自己的计算机水平才开始真正走上正轨。说实话，一开始面临找工作的问题，自己心里也不是那么有底的，非CS科班出身，一些知识点很散，不太成体系，导致知识面也许够宽，但蜻蜓点水的情况偏多。这也是非CS专业的人找工作的时候表现出来的一个通病。</p>

<p>俗话说，“预则立，不预则废”，硕士阶段两个大目标其实也挺清晰的-毕业&amp;找工作。这两条主线贯穿始终，借用一位同学的话，你需要花两年的时间，认认真真地去“填”你的简历。所以，找工作真的不是那么一两个月的事情（水平很高的人请忽略），更多地把它当成一个系统的项目来做，往往最后会得到自己满意的结果。接下来简单从几个方面谈一谈如何去做准备工作（特指IT行业），希望能给大家一些启发(更多内容请参考我的slides &ndash; <a href="http://www.slideshare.net/calmli/some-experiences-and-lessons-learnt-from-hunting-a-job">找工作的一点经验和教训</a>)。</p>

<h2>时间表</h2>

<p>这里给出我个人认为比较合理的一个时间安排。研二的寒假开始梳理找工作事宜，推荐《程序员面试金典》的前面几章，思路很清晰。开始制定技术准备的计划，要看的书，要刷的题。基本上3-5月份默默修炼就好，6-7月可以寻找一些实习面试的机会，一来检验自己，二来找面试感觉。8月差不多开始正式战场（有的在7月份，比如去年的FB，这个大家注意留意就好），这时候基本就是笔试面试，总结，准备，再笔试面试，这一阶段有的时候挺微妙的，你可以发现自己前所未有的可以看清楚自己的内心活动，不管是喜悦还是沮丧。这个阶段，你的情绪也会变得更加敏感，突然的一个Offer，冷不丁的一个拒绝，都会在你内心荡起波澜。我是比较好的开局，之后陷入泥潭，后来又慢慢爬出来。虽然面试的进行，心态也会慢慢发生变化，长时间找工作的一大好处就是这个体验了，有很多认真深入思考的机会（有的时候是不得不思考了）。基本上10月的时候高峰期就过去了，这个时候，主战场基本结束了，但是不要过早地撤离，经过浴血奋战，你已经很有战斗的感觉了，所以可以权衡下手里的Offer，学习并体验一下“谈判技巧”，然后再看看有没有更好的机会。顺利的情况下，这是一个丰收的时刻，但难免很多纠结，这个时候注意不要跟身边的人做太多比较，追求自己想要的就好。</p>

<h2>技术储备</h2>

<p>基础的《数据结构》和《算法》个人认为最重要，值得花大时间，因此校招考查很难逃出这个范围（《算法导论》足矣）。我之前没上过这方面的课程（其实有相关课程，但跟没上过基本等效了，有点后悔当时没有认真跟着课堂走，否则可以省不少时间），所以花时间过了一遍《数据结构C语言版），后来花时间看了一部分《算法导论》，感觉十分有用！《操作系统》一定要有基本的了解吧，至少对“线程/进程”有个清醒的认识，《计算机网络》至少了解TCP/IP的基本概念，三次握手，etc。语言层面如果不是特别偏Java，建议用C/C++练习写算法，现在考察的时候这个比较主流的样子（当然这可能是我的主观感受）。C++的《深入理解对象模型》，《STL源码剖析》强烈推荐。其他的书籍参考<a href="http://www.slideshare.net/calmli/some-experiences-and-lessnons-learnt-from-hunting-a-job">slides</a>吧。</p>

<p>如果面“机器学习”，“数据挖掘”的岗位，那要把相关课程过一下，然后基本概念一定要清楚。这里经验不太多，不过多讨论了。总结来说就是，根据你想找的工作岗位，除了基础知识（数据结构和算法），针对性地准备，不要觉得这样功利，遵守游戏规则而已。</p>

<h2>临场表现</h2>

<p>心态第一，笔试面试第二。注意沟通，随机应变。跟人感觉的话，首先是自信，然后是态度端正，绝对谦虚，给面试官足够的尊重。不要过于沉默寡言，该问的要问，该表达的想法要适当表达，但也切忌话太多，言多必失，且太多话真的容易招人反感（个人观点）。</p>

<p>好好做题目，做到自己能够做到的最好程度。面试的过程就是表现自己的过程，把你的思维，思考方式都给面试官看，最好把你好学的一面也表现出来（真切的，不要装）。对于你来说，你是在争取一个Offer。而对于面试官来说，他在寻找一位同事，一位他愿意一起共事的人，知道了这一点，该如何表现其实变得容易了，不是吗？</p>

<h2>知己知彼</h2>

<p>这里特指谈Offer阶段吧，每年都有special啊，白菜价之类的，其实在找工作的过程中，少不了和周围同学的讨论，每年的行业也相对明朗。你自己的水平如何，面试表现如何，开了什么价位，是否匹配，自己完全可以判断的。这里的核心还是手里要有过硬的Offer吧，否则谈起来也不太容易。</p>

<h2>继续跑</h2>

<p>以为找完工作就结束了？Totally wrong！找完工作之后，即使拿到了还算不错的Offer，也真的觉得自己有太多的东西可以加强！So，努力提高自己的市场价值吧，努力的你会拿到自己应得的价的:&ndash;)</p>

<p>No pain, No gain. Good luck, a great job is awaiting:&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014这一年]]></title>
    <link href="http://hustcalm.me/blog/2015/01/04/2014-zhe-yi-nian/"/>
    <updated>2015-01-04T19:37:09-08:00</updated>
    <id>http://hustcalm.me/blog/2015/01/04/2014-zhe-yi-nian</id>
    <content type="html"><![CDATA[<p>想一想，总还是要说些什么，书写是为了更好地思考，总结是为了更好地前进。2014年总感觉从没有开始过，也还没有结束，其实一直觉得读研以来总是在连续地往前走，不曾中断似的。不过既然思绪还热乎，先总结一下自己2014的得与失，在另外一篇文章<a href="">13-14一起过</a>中再讨论这“持续”的研究生生涯。</p>

<p>总的来讲，2014有三条主线：</p>

<ul>
<li>做产品</li>
<li>找工作</li>
<li>搞科研</li>
</ul>


<!--more-->


<p>其中第一件事是一个团队在战斗，也证明了团队的确是有战斗力和凝聚力的，嗯，NG继续加油！后两件事情，虽也有他人的沟通交流，比如同学，导师，但更多是一个人在探索，诉求，挣扎，奋斗！下面先按照这三条主线展开，之后再简单谈谈2014的得与失，扯扯生活的其他方面方面。</p>

<h3>做产品</h3>

<p>缘分让五人聚在一起，开始琢磨一款对社会有价值的产品，最终定位在大学生市场，找实习和找工作。找工作这里，有了各种招聘网站，不太好下手。所以，从找实习入手，我们希望打通大学生和企业之间实习生招聘的桥梁。</p>

<p>找实习的流程，看招聘信息->投简历->笔试面试->录用or拒掉->看招聘信息->&hellip;。所以这里有很多的事情可以做，我们基本上只做了第一个环节，那就是把全而优质的实习生招聘信息呈现给大家。做了一款App，叫做《蛙实习》，聚合北邮人论坛，水木清华BBS以及毕业生就业信息网的实习生招聘信息，支持基本的搜索，收藏，分享，etc。</p>

<p>后台服务器买了美团云（一个月254左右），GitHub上付费托管了，买了俩域名，五个人都是兼职工作。每个周日上午聚在一起讨论，嗯，那段时间想想还真有一种幸福的感觉呢。前后三个月，产品就这样上线了，只是在北邮人论坛简单推广了一下，每天大概1000+访问吧，至少我们自己也要找实习，找工作，使用起来还算舒心。技术上倒没有啥难点，不过一个完整的产品开发流程以及运作流程，多少让我们获得了不少一手的经验。</p>

<p>如今团队的成员各自在自己的前线战斗，开发和维护停滞了，产品算是暂时“死掉了”。However，we will make something amazing one day!</p>

<h3>找工作</h3>

<p>也许之后会专门写一个找工作的总结帖，毕竟前后不少时间都在为找工作花心思，这里简单记录一下应聘经历和心里路程。</p>

<p>研二的寒假有了找工作的意识，简单翻了翻《程序员面试金典》，这本书和《剑指offer》和《编程之美》被我自己称为三剑客。开学后，各大实习招聘如潮涌来，阿里巴巴，腾讯，微软，网易游戏，etc。我比较保守，只面了阿里，当时说实话有一丝紧张，因为《数据结构》才走马观花过一遍，只能是抱着找经历的心态。第一面阿里妈妈的人，第二面阿里云的人，我自心底是希望去阿里云的，因为当时还把技术排在最高优先级，尤其是云计算的各种技术。这里的插曲是，阿里发offer的纠结，第一批，第二批神马的。最后发了，竟有一丝欣喜，想想真是没见过世面啊。之后是Works
Applications，一家做ERP的日企，薪水很诱人，抱着试一试的心态很努力地准备，成功了！之后去东京参加Tokyo Event，为找工作奠定了一步好棋！回来后，在阿里云短暂实习混经历，这个时候同时做几件事情，阿里实习，实验室的工作，刷leetcode并看书，参加CSDN的开源夏令营（跟着teawater大哥学习），参加面试，etc。</p>

<p>然后是百度，拿到了NLP部门的special，被商搜拒掉。中间心理上有不少起伏，旗开得胜有些自信满满，连续有道，雅虎北研悲剧，又有些生畏。不过，这个时候是对一个考验和成长的最好时刻了，调整下继续战斗，心态多少也更加平和了。总结一条，多大的实力，拿什么样的offer。面Google第一轮，还好，到了第二轮，没抓住第三面的机会（跟面试官多少有些关系，不过最终是自己没把握好），第四面就没啥大感觉了。体会是，Google的面试没有那么困难，一定要自信，展现自己的实力即可！</p>

<p>中间各种纠结，对吧，我想每个人都会有类似的体会，户口啊，待遇啊，未来的发展啊，etc。不多说了，找工作的人都有体会。最后过了六面的微软面试，进入了MSRA，职位是RSDE。自己对这个结局还算满意，最重要的是，自己的努力是值得的！</p>

<h3>搞科研</h3>

<p>从来不觉得科研有什么好搞的，那是之前的想法啦。踏实想做好一个算法，写一篇自己满意的论文，说实话，还是挺费心思的。</p>

<p>研一的课程开了下视野，知道了研究生都在学习些什么，然而到了实验室发现，课本中的东西真的只是基础，是你想把paper读懂的前提知识。研二上学期和一个老师合作一个项目，自己做了绝大部分的工程，最终出差一次，项目顺利结题。之后，开题，自己给自己挖了个大坑。这个坑，就是自己的小论文了。项目结束后，就应该写一篇，锻炼自己的写作能力的。然后很长一段时间，实现一篇论文中的系统，发现自己有太多需要提高。中期的时候，心里略不踏实。</p>

<p>现在投稿了一篇英文文章，跟研二上学期的项目相关的，实验室的老师从idea到最后文章的锐色帮了太多的忙。接下来，希望自己能够认真独立完成一篇文章，体验一下科研的感觉。未来，努力成为一名快乐的科研工作者，也是一条很愿意走的路:&ndash;)</p>

<h3>杂谈</h3>

<p>还有一件事情值得提一下，那就是轮滑，这一年，确定了轮滑成为自己的两大体育项目之一，另外一个是篮球。北京到天津的轮滑之旅，让我认识到自己可以很有毅力，很能坚持。之后的周五晚上，也成为自己的一大放松方式，最重要的是收获的一批朋友。中科院的刷刷们，感谢你们！</p>

<p>2014年，有泪水有欢笑，有成绩有遗憾，2015，看我披荆斩棘，乘风破浪！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Playing With Kinect for Windows Using OpenNI and SensorKinect Under Ubuntu 12.04 LTS]]></title>
    <link href="http://hustcalm.me/blog/2014/12/31/playing-with-kinect-for-windows-using-openni-and-sensorkinect-under-ubuntu-12-dot-04-lts/"/>
    <updated>2014-12-31T00:19:56-08:00</updated>
    <id>http://hustcalm.me/blog/2014/12/31/playing-with-kinect-for-windows-using-openni-and-sensorkinect-under-ubuntu-12-dot-04-lts</id>
    <content type="html"><![CDATA[<p>Just a quick recap to make myself feel better after such a struggle for 1 day and hopes it does some help to those who tries to bring <strong>Kinect For Windows</strong> work under Linux, here Ubuntu especially.</p>

<h3>Hardware Device</h3>

<p>Kinect for Windows, not Kinect for XBox, so this post is kind of limited to some senarios. And I&rsquo;m currently using Kinect For Windows Version 1, not the fasion V2.</p>

<!--more-->


<h3>Some Concepts</h3>

<ul>
<li>gspca_kinect</li>
</ul>


<p>A simple Kinect kernel driver which has been integrated in the driver, and works by default on my Ubuntu. Think <strong>V4L</strong> or <strong>UCV</strong>, this driver allows you to access the RGB and depth frames from Kinect. See <a href="http://blog.jozilla.net/2012/03/29/getting-up-and-running-with-the-kinect-in-ubuntu-12-04/">Getting up and running with the Kinect in Ubuntu 12.04</a>. Note however the author is using a Kinct for XBox.</p>

<ul>
<li>OpenNI</li>
</ul>


<p>While, open source Kinect SDK supported by PrimeSense?</p>

<h3>Verify &amp; Install</h3>

<p>Follow <a href="http://choorucode.com/2013/07/23/how-to-get-started-with-kinect-for-windows-on-ubuntu-using-openni/">this</a>, if got compilition error, maybe you are lucky with <a href="https://github.com/avin2/SensorKinect/pull/5">this patch</a>.</p>

<h3>Try Something Cool</h3>

<p>Why not play with <a href="https://github.com/felixendres/rgbdslam_v2">RGBDSLAM</a>?</p>

<h3>Links That Matter</h3>

<ul>
<li><a href="http://choorucode.com/2013/07/23/how-to-get-started-with-kinect-for-windows-on-ubuntu-using-openni/">How to get started with Kinect for Windows on Ubuntu using OpenNI</a></li>
<li><a href="http://blog.jozilla.net/2012/03/29/getting-up-and-running-with-the-kinect-in-ubuntu-12-04/">Getting up and running with the Kinect in Ubuntu 12.04</a></li>
<li><a href="http://pointclouds.org/documentation/tutorials/openni_grabber.php">The OpenNI Grabber Framework in PCL</a></li>
<li><a href="http://mitchtech.net/ubuntu-kinect-openni-primesense/">Ubuntu + Kinect + OpenNI + PrimeSense</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[成长就是蜕变]]></title>
    <link href="http://hustcalm.me/blog/2014/12/25/cheng-chang-jiu-shi-shui-bian/"/>
    <updated>2014-12-25T16:57:39-08:00</updated>
    <id>http://hustcalm.me/blog/2014/12/25/cheng-chang-jiu-shi-shui-bian</id>
    <content type="html"><![CDATA[<p>好几个月没来这块自留地了，觉得甚是不妥，心里也不那么踏实。最近，脑海里常浮现两个字，那就是“成长”；成长在每一个人看来也许含义都大不相同，我理解的成长“就是蜕变”。</p>

<p>我想说什么呢？蜕变是一个过程，最直观的比喻便是“破茧成蝶”，经历了磨砺和长时间的积累，才终有之后绚丽的身姿；蜕变也是一种选择，最近老在想，通过观察，也察觉到，这个世界和社会真的是缤纷多彩（乱七八槽），每一个独立的个体都面临着各种各样的选择，把选择简化一下，用几对词来描述，可以有好几个方面的分析，积极 V.S. 消极，向上 V.S. 退后，大局 V.S. 个人，克服 V.S. 退缩，责任 V.S. 散漫，蜕变 V.S. 自缚！</p>

<!--more-->


<p>人终究是复杂的，也有各种纠结，这个时候仿佛“简单一点”的人，都会受到他人的羡慕，为什么呢？纠结来源于选择，而终极原因则是欲望罢了，复杂就在这里了，为了得到太多的东西，终究是得推着自己“忙碌”，忙忙碌碌心情浮躁，也就很难做一个“简单一点”的人了。古人说，“无欲则刚”，想想还真是人间真理，四个人说透了人类痛苦的来源之一，可在这个“精彩”的世界，有着太多的诱惑，哪个“傻子”能抵制得住哩！因为，大家都是“正常人”嘛！没有读过“人性的缺点”之类的书，但是如果用“准许为人”这么高端积极的词汇为自己的“不作为，懒惰，自私”开脱，那可真是可笑哩！</p>

<p>写到这里，忽然想起了“鲁迅先生”，在林林总总的大文豪中，他老人家是我最喜欢的，为什么？读书少，《语文》课本上鲁迅的文章太多，又偏巧自己喜欢“鲁迅”的行文风格，什么“我家门前有两棵树，一颗是枣树，另一颗还是枣树”的幽默，抑或“这个世界上本没有路，走的人多了，也就有了路”的经典，都让人十分喜爱。小时候买的不多的“文学书”中，《鲁迅文集》是一本翻的最多了的，可那时候啥都不懂，根本不知道“鲁迅先生”笔下文字的重量和分量，这着实是“脱节严重”！说到这里，前段时间的电影《黄金时代》是我在课本之外，通过电影银幕，对鲁迅先生认识最深的一次再教育，《语文》课上的那个“思想家，革命家，教育家”如此虚无缥缈，因此当我在银幕上看到“先生”本人，心里还真是有点激动。所以，那部长达3小时的电影，我看得津津有味，因为“鲁迅先生”是主角嘛，二萧给人的触动倒没有那么大了。</p>

<p>蜕变是“质变”，但确是在无数“量变”之后自然发生的。天将降大任于斯人，必先苦其心志，劳其体肤，这个过程都是“量变”。当斯人能够接过“大任”，那必是“质变”发生之时！任何过于快速的“质变”都是不自然的，也是畸形的，也是无法担当大任的。拿技术圈子来说，最近团队的一位老师就“牛人的壁垒”展开讨论，提出“技术壁垒”，“时间壁垒”和“成果壁垒”，并总结出：（1）大家要建立自己的技术壁垒并保持下去；（2）技术壁垒需要持续的时间投入，要有耐心，这就是时间壁垒；（3）把技术壁垒转化为成功、更容易被人认可的产品，更有说服力。在这里面，我觉得“持续的时间投入”是核心点，对于一门技术，踏实积累一年，定能略窥门径！假以三年五载，则一技术专家成矣！为什么如此简单的道理，读了大学本科的人，极少数成为了大家眼中的“牛人”和“技术专家”呢？呵呵，自己悟！</p>

<p>距离起初写这篇文章到现在，不觉已有两个月的光阴了，真是后悔当时没有一气呵成，搞得现在竟不知自己想说些什么了。如此，那就再发散一下无妨。</p>

<p>成长是一个扩展视野的过程，是对一个人自身的升华！一句话说得好，只缘身在此山中。最近一直在想，其实世界上很多的人，很多的时间，都是带着错误的认知在生活的。很多时候，矛盾什么的，也许都来自于一个人的无知和夜郎自大。人们仿佛都喜欢活在自己的世界里，好比井底之蛙，它的世界其实很大，只要大到它认为世界是这个样子的就可以了。在历史的长河中，好像认知到世界视野级别的人，都能够或多或少留下一笔。那么如何增加一个人的认知呢？我觉得“读万卷书，行万里路”是一个很好的概括，再加上“思万家事”，慢慢地一个人会形成一套自己的人生观，价值观，而世界观则一定程度上取决于你是如何观世界的。</p>

<p>一个人在成长的过程中会扮演不同的角色，刚开始比如说是儿子，女儿，孙子，孙女，etc。然后是学生，学徒，同学，朋友，etc。之后也许还有战友。走上工作岗位，也就是大家说的进入社会吧，又有职工，同事，老板，各种工种，比如程序员，etc。喜欢有个家的，还会从男女朋友进化到婚姻阶段，成为丈夫和妻子，之后成为父亲和母亲，一大家子，七大姨八大姑，etc。还有很多其他的社会角色，这里就不啰嗦了。我想说什么呢？不同的角色的思考方式是会发生不小的变化，且这种变化也是自然的，一个人在成长的过程中需要试着去接受各种各样的变化，去适应并做好自己的角色。所以，肯定青春期会动荡一下，这里忽略很多其他的因素不提了，比如你想有个女朋友啊什么的，etc。在角色转换的过程中，现代社会貌似存在着很多的失控，比如说之前的包办婚姻，如今的相亲，结为夫妻的二人，对于发生的角色变化无所适从，自然就会滋生不少问题。失控大多来自于外界的压力，父母的压力，亲戚朋友的评论，etc。其实很多时候，我在想，学生这样一个角色，尤其是本科时期的时候，真的是全世界最自由的一批人啊，如果7年前，我有此觉悟，我的本科一定会更加折腾一些的！不过说到这里，便稍稍印证了，还是事后诸葛亮多，很多事情，很多阶段，回头看的时候，心里明白得很，而就在当时心里糊涂得很。没有关系，这就是成长的烦恼吧，在成长的过程中，不断进化自己，才能越走越安心。</p>

<p>小的时候，大家都拥有单纯的梦想或者理想，我想当一名科学家，我想做一个宇航员探索太空，我想做一个老师，医生，警察，飞行员，etc。可是又有多少人实现了自己的理想呢？随着年龄的增长，理想越来越丰满，现实却骨干地让人失望。拿好的成绩，考上好的大学，谈一个漂亮的女朋友，找一份好的工作，过上幸福生活之后，却早已发现，理想什么的，早已经和自己相距十万八千英尺了。我个人的分析，有两个方面导致“理想的流产”。第一个就是确定理想的时候，天马行空，只是心中一份美好的想象，当然小孩子的时候这个很正常。不过此时，父母就起了致关重要的作用了，如果做充分的沟通，对理想做一下修饰，也许会好很多。如此，很快，小孩子也许就会被淹没在作业和考试中，和理想说再见了。长大后，发现，哦，原来自己没啥理想，这可咋办？第二个就是，随着阅历的增长，渐渐认识到自己实力有限，或者说努力程度有限，无法支撑自己的理想。如果是前者，那么也许真的需要调整一下自己的抱负了，不要跟自己的IQ和EQ较劲，否则会头破血流。而对于后者，则取决于心态了，相应的努力会得来应有的回报。No pain, no gain！</p>

<p>不过，到了一定阶段，抛却理想不谈，每个人会慢慢认识到自己期望的生活方式。想周游世界？想老婆孩子热炕头？想大干一番，千万富翁？还是好好上班，好好锻炼，好好对待每一个人？一旦确定了生活方式，大家都会舒服不少，至少不会被太多的选择煎熬了。这个时候心态好像成为了关键，因为每个人的生活方式大大不同，你选择了自己的，那就最好尊重她，净重她，而不是各种不满意，嫉妒他人的“逍遥生活”。当然了，穷则变，生活方式肯定可以通过一个人的努力得到改变或者说改善。</p>

<p>吾日三省吾身，温故而知新，这都是对每一个人的金玉良言。大和小，真的只在一念之间。活在你小小的世界中，你的价值观会试图匹配你的世界。而活在大千世界，你的认知会不断适应你对这个世界的观察。这也是我发现人生很有意思的一点，之前你觉得很困难的事情，慢慢却变成了你擅长的东西。之前你认为是全世界第一定律的东西，却在某一个阶段被自己彻底推翻。嗯，这就是蜕变吧，变化是永恒的，拥抱变化才是我们的生存之道！</p>

<p>当你未对这个世界有足够的认识，那就继续保持一颗美好的好奇心，不灭的热情快乐地探索吧。吾生也有涯，蜕变也无涯！</p>

<p>When you change the way you think about the world, you can change the world you think about!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started With ElasticSearch and Plugin Development]]></title>
    <link href="http://hustcalm.me/blog/2014/08/10/getting-started-with-elasticsearch-and-plugin-development/"/>
    <updated>2014-08-10T03:33:53-07:00</updated>
    <id>http://hustcalm.me/blog/2014/08/10/getting-started-with-elasticsearch-and-plugin-development</id>
    <content type="html"><![CDATA[<p>Coming across to <code>ElasticSearch</code> when preparing for the programming chanllege held by WorksApplications in Tokyo Event, and falling love with her after then. Well, with no much new techonoligies involved, <code>ElasticSearch</code> is definitely a beautiful piece of software and a successful product. Claimed that with the core search engine powered by <code>Lucene</code>, providing <code>RESTful interface</code> and born as a distributed and scheme-free search oriented product, <code>ElasticSearch</code> has boosted the huge
business of <strong>Github</strong> with billions of lines and <strong>Stackoverflow</strong> with billions of Q&amp;A.</p>

<p>After digging some 101 tutorials around, I found it easy to set up <code>ES</code>(abbreviated for ElasticSearch and will use afterwards) and begin to play in 10 minutes. However, to understand what is going on underhood and what is the most tricy and interesting part, also to those who try to develop plugins to enpower <code>ES</code>, I will share something which would be useful for newbies. There are already tons of tutorials online, to same your time, please see
<a href="https://github.com/hustcalm/elasticsearch-getting-started">elasticsearch-getting-started</a> hosted on my github for a good cheat sheet.</p>

<!--more-->


<h3>Basic Concepts of ES</h3>

<p>Someone got to do the dirty work when something happens so naturally and gracefully. <code>ES</code> is graceful enough to just give users <code>RESTful</code> interfaces and everything is done! You can just do <code>CRUD</code> operations as naturally as just sending some HTTP request to some urls according to some predefined rules. So, we know at this moment that, <code>RESTful</code> interfaces are a great method to bridge <code>ES</code> and <code>end users</code>. So, for the <code>CRUD</code>, what are mainly involved?</p>

<p>To start with familiar concepts, let&rsquo;s go with <code>Database</code>. OK, when you get a <code>Database</code>, it is basically a container for all your data. You can create varies of <code>Tables</code> in a <code>Database</code>, for a specified <code>Table</code>, you would firstly define a scheme for it, as the first column should be <strong>_id</strong> as integer numbers, the second should be <strong>_name</strong> as strings, etc. Then in a <code>Table</code>, you would have many <code>Rows</code>, each <code>Row</code> relates to a specified <code>record</code>. If you know this well, it&rsquo;s easy to catch up
with <code>ES</code>, after some adaptations to shift with the search engine background.</p>

<p>Forget about the storage engine for good, let&rsquo;s see what is included in a <code>RESTful</code> url.</p>

<h4>Index</h4>

<p>An <code>index</code> is basically a <code>Table</code> to contain varies of <code>Documents</code>, here <code>Document</code> again means <code>record</code>. So basically when you do a search, you are searching on an <code>index</code> or multiple <code>indexes</code> at the same time. No trick at all here, <code>ES</code> will maintain <code>inverted index</code> for each <code>field</code> of each <code>document</code> in an <code>index</code>, also some other <code>inverted index</code> will be generated for search, so an action of search is actually matching the <code>query</code> or user input keywords with the <code>inverted index</code>
records. For easy understanding, think it as a book, when you try to lookup a word, instead of searching for it from the very beginning page by page, just see the <code>Word Index</code> for a happy ending.</p>

<h4>Type</h4>

<p>Yes, <code>ES</code> can have different kinds of <code>Documents</code> in an <code>index</code>. What does that mean? In <code>MySQL</code>, can you have different kinds of <code>Records</code> in a single <code>Table</code>? Found it impossible, huh? <code>ES</code> can save you for free, here different kinds, we can also say different <code>Types</code>. Think it this way, you have many documents in an <code>index</code>, and not all the documents are the same kind, let&rsquo;s say, doc1 contains just a long text paragraph, doc2 contains another number indicating the number of
words of one paragraph besides a long text paragraph, doc3 maybe contain another field for storing some comments and doc 4, etc. Thus we can have many kinds of <code>Documents</code> in a single <code>Index</code>, maybe each document is one kind, or there are m tpyes for n documents(n >= m). Got any idea about this?</p>

<h4>Mapping</h4>

<p>Claimed as <code>scheme-free</code>, the magic is really played by <code>guess</code> or <code>a default scheme framework</code>. If you try to creat an <code>index</code> and put <code>documents</code> in it, <code>ES</code> will try to construct the index according to a default manner, for example, storing the field as <code>string</code> and <code>anylyzed</code> using the default anylyzer.(An anylyzer is used to splitted a sentence or phrase into independent words, in order to let people search partial keywords in a document.) If the dafault scheme is just working good,
you need not do anything. However, unfortunately this is not always the case, so we just mentioned that we have many <code>Types</code> of <code>Documents</code> in an <code>Index</code>, to change the way that <code>ES</code> is treating how each <code>Type</code> of <code>Document</code> is processed, we can specify a <code>Mapping</code> for each <code>Type</code>. Well, for <code>Mapping</code>, it is actually a <code>scheme</code> specified by user, isn&rsquo;t it?</p>

<h4>ID</h4>

<p>Well, well, finally we can put our <code>Documents</code> now. For each document, specify a <strong>ID</strong> when uploading to <code>ES</code>, such as <code>PUT /megacorp/employee/1</code> and <code>PUT /megacorp/employee/2</code>, here <code>1</code> and <code>2</code> are both <code>IDs</code>. Again for retrieving a specified document from <code>ES</code>, specify the <strong>ID</strong> also, as <code>GET /megacorp/employee/1</code>.</p>

<p>OK, I think you are ready to go after being familiar with the basic concepts. Let&rsquo;s talk about something about <code>search</code>.</p>

<h3>Search using ES</h3>

<p>Simple and beautiful, <code>ES</code> is smart enough for basic searcing, even real-time suggestions and near real-time search is supported. So you want to search?</p>

<pre><code>GET /megacorp/employee/_search
GET /megacorp/employee/_search?q=last_name:Smith
</code></pre>

<p>Try this!</p>

<p>For more sophiscated searches, try using <code>Query DSL</code>, like:</p>

<pre><code>GET /megacorp/employee/_search
{
    "query" : {
        "match" : {
            "last_name" : "Smith"
        }
    }
}
</code></pre>

<p>I won&rsquo;t talk too much about <code>Query DSL</code> here, go dig the <a href="http://www.elasticsearch.org/guide/en/elasticsearch/client/java-api/current/query-dsl-queries.html">ES Reference</a>.</p>

<h3>Client API</h3>

<p>As <code>Luncene</code> is born with <code>Java</code> blood, <code>Java</code> is the native client API for <code>ES</code>. Everything you can do with <code>RESTful</code> interfaces, you can get it done with <code>Java API</code> or other programming language bindings. However, comparing to the <code>RESTful</code> style, all the bindings suck a little especially when having to construct complicated searches or aggregations, using <code>Qeury DSL</code> is too much graceful than any <code>Client API</code>.</p>

<p>The <a href="http://www.elasticsearch.org/guide/en/elasticsearch/client/">ES Reference</a> has detailed documentation on each <code>Client API</code>, go and find your own one.</p>

<h3>Plugin Development</h3>

<p>Well, as the development of <code>ES</code> is evolving too rapidly, I guess, the APIs and even fundamental classes are not stable enough, so for plugin development, there are not good official tutorials to follow. However, some good guys who have the training maybe, give some useful references to getting people started. Or, maybe they just hack the source code to figure out how, admirable! For <code>ES</code> plugins, there are basically two types, one is <strong>site</strong> plugin, the other is <strong>non-site</strong> plugin.</p>

<h4>Site Plugin</h4>

<p>As we said, all the <strong>CRUD</strong> operations can be done through <strong>RESTful</strong> interfaces, so basically speaking, a <strong>site</strong> plugin is a wrapper or delegation for easier <code>RESTful</code>, mainly focusing on the <strong>front-end</strong>. Any programming language or tools which are capable of sending and receiving of HTTP requests can be used, however <code>JavaScript</code> seems to be the most chosen one since it is so flexible and repid prototyping.</p>

<p>For a great example, see <a href="http://mobz.github.io/elasticsearch-head/">ElasticSearch Head</a>.</p>

<h4>Non-Site Plugin</h4>

<p>As a <strong>site</strong> plugin, we are actually doing the user end work, as we are not playing with the <code>ES</code> source code or core component directly. For <strong>non-site</strong> plugin, we will write some <code>Java</code> code, inherate from some abstract classes relating to <code>Plugin</code> and <code>Module</code>.</p>

<p>A <code>Plugin</code> will be instanced when loaded by <code>Plugin Manager</code> of <code>ES</code>, then the related <code>Modules</code> will be loaded, and the real job will be done through <code>Module Handlers</code>.</p>

<h4>Good Example</h4>

<p>For a complete reference and vivid example for plugin development, see <a href="https://github.com/hustcalm/elasticsearch-getting-started">elasticsearch-hotsearch</a> developed by <strong>Cgroups</strong> during the <strong>Tokyo Event</strong>.</p>

<h3>Summary</h3>

<p>For good overview and other references after reading this blog, see my github repo <a href="https://github.com/hustcalm/elasticsearch-getting-started">elasticsearch-getting-started</a>.</p>

<p>We learn basic concepts of <code>ES</code> here, knowing <code>Client API</code> and <code>Plugin Development</code>, however, we don&rsquo;t cover <code>Distributed</code> and other interesting parts of <code>ES</code> here. By starting from here, I believe you are capable of digging deeper by yourself by referencing the official site and other guys&rsquo;s posts. Though the official documentation is under construction by the time when writing this post, people like you who read this post will find it no difficulty to move on:&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KGTP中增加对GDB命令“set Trace-buffer-size”的支持 - Week 4]]></title>
    <link href="http://hustcalm.me/blog/2014/08/10/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-4/"/>
    <updated>2014-08-10T03:33:09-07:00</updated>
    <id>http://hustcalm.me/blog/2014/08/10/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-4</id>
    <content type="html"><![CDATA[<h3>CSDN开源夏令营 &ndash; 第四周工作总结</h3>

<p>本周主要是在回顾“set trace-buffer-size”完成通信的基础上，对于指定参数size的处理，比如指定-1或者unlimited的时候，在KGTP端该如何做解析，以及该如何处理此时的buffer size。同时，根据“开题报告&#8221;的进度，中期检查的任务已经完成。对Trace Buffer的实现，做了初步的调研。</p>

<h4>1. GDB和KGTP通信实现的回顾</h4>

<p>利用GDBRSP，即GDB Remote Serial Protocol，GDB远程串行通信协议。简单来说，用于GDB远程调试发包，但是也支持File I/O和Console，而KGTP正是利用了GDBRSP对于File I/O的支持，完成GDB和KGTP的通信，在接受到GDB发送的Packet后，KGTP进行解析。而通信的介质则是通过debugfs或者其他kernel space和user space进行数据交换的接口进行的。
具体实现，可以参考上一篇博文[1]。</p>

<!--more-->


<h4>2. GDB的Packet格式</h4>

<p>GDB向target发送的Packet必须遵守提前设定的约定，才能被target按照相应的规则解析处理。关于GDB的Packet格式，可以参考[2]，这里详细列出了所有的预定义的指令和它们相应的响应数据。如果想进一步了解GDBRSP，可以阅读[3]。由于KGTP对Trace Point最感兴趣，因此我们也最关注Tracepoint Packets，只要有两种，分别以Q和q开头，其中Q表示设置命令，即set，而q表示查询命令，即query，具体看[4]。关于如何开始和停止Trace Experiments，看[5]。GDB对于用户输入的commands，会转换后封装成Packet，通过GDBRSP发给target，因此需要结合着[4]和[5]才能把对某一个命令如何进行包解析搞清楚，比如用户输入”tstart“，则会发送一个”QTStart“的包。</p>

<h4>3. KGTP对GDB的Packet的处理实现</h4>

<p>有了GDB和KGTP的通信的基础设施，比如DebugFS和GDBRSP，正常的文件读写即可完成GDB和KGTP的数据交换。而为了完成相应的任务，KGTP必须对接收到的GDB的Packet进行解析，而我们又知道了GDB得Packet格式，因此只需要对接收到的数据按照格式做相应的解析即可。</p>

<p>在<code>gtp.c</code>的<code>gtp_write</code>函数，针对接收到的GDB包做了具体的解析，具体代码如下：</p>

<pre><code>static ssize_t
gtp_write(struct file *file, const char __user *buf, size_t size,
      loff_t *ppos)
{
    char        *rsppkg = NULL;
    int     i, ret;
    unsigned char   csum;
    int     is_reverse;

    if (down_interruptible(&gt;p_rw_lock))
        return -EINTR;

    if (size == 0) {
#ifdef GTP_DEBUG
        printk(GTP_DEBUG "gtp_write: try write 0 size.\n");
#endif
        goto error_out;
    }

    size = min_t(size_t, size, GTP_RW_MAX);
    if (copy_from_user(gtp_rw_buf, buf, size)) {
        size = -EFAULT;
        goto error_out;
    }

    if (gtp_rw_buf[0] == '+' || gtp_rw_buf[0] == '-'
        || gtp_rw_buf[0] == '\3' || gtp_rw_buf[0] == '\n') {
        if (gtp_rw_buf[0] == '+')
            gtp_rw_size = 0;
        size = 1;
        goto out;
    }

    if (size &lt; 4) {
        size = -EINVAL;
        goto error_out;
    }
    /* Check format and get the rsppkg.  */
    for (i = 0; i &lt; size - 2; i++) {
        if (gtp_rw_buf[i] == '$')
            rsppkg = gtp_rw_buf + i + 1;
        else if (gtp_rw_buf[i] == '#')
            break;
    }
    if (rsppkg &amp;&amp; gtp_rw_buf[i] == '#') {
        /* Format is OK.  Check crc.  */
        if (gtp_noack_mode &lt; 1)
            gtp_read_ack = 1;
        size = i + 3;
        gtp_rw_buf[i] = '\0';
    } else {
        printk(KERN_WARNING "gtp_write: format error\n");
        size = -EINVAL;
        goto error_out;
    }

    wake_up_interruptible_nr(&gt;p_rw_wq, 1);

    up(&gt;p_rw_lock);
    if (down_interruptible(&gt;p_rw_lock))
        return -EINTR;

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_write: %s\n", rsppkg);
#endif

    /* Handle rsppkg and put return to gtp_rw_buf.  */
    gtp_rw_buf[0] = '$';
    gtp_rw_bufp = gtp_rw_buf + 1;
    gtp_rw_size = 0;
    ret = 1;
    is_reverse = 0;
    switch (rsppkg[0]) {
    case '?':
        if (gtp_current_pid == 0)
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "S05");
        else
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "T05;thread:p%x.%x;",
                 gtp_current_pid, gtp_current_pid);
        gtp_rw_size += strlen(gtp_rw_bufp);
        gtp_rw_bufp += strlen(gtp_rw_bufp);
        break;
    case 'g':
        ret = gtp_gdbrsp_g();
        break;
    case 'm':
        ret = gtp_gdbrsp_m(rsppkg + 1);
        break;
    case 'Q':
#ifdef GTP_RB
        /* This check for "tfind -1" and let GDB into step replay.
           XXX: just test on X86_64.  */
        if (gtp_replay_step_id) {
            if (strcmp("QTFrame:ffffffff", rsppkg) == 0) {
                ret = 0;
                goto switch_done;
            } else
                gtp_replay_reset();
        }
#endif
        if (rsppkg[1] == 'T')
            ret = gtp_gdbrsp_QT(rsppkg + 2);
        else if (strncmp("QStartNoAckMode", rsppkg, 15) == 0) {
            ret = 0;
            gtp_noack_mode = -1;
        }
        break;
    case 'q':
        if (rsppkg[1] == 'T')
            ret = gtp_gdbrsp_qT(rsppkg + 2);
        else if (rsppkg[1] == 'C') {
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "QC%x",
                 gtp_current_pid);
            gtp_rw_size += strlen(gtp_rw_bufp);
            gtp_rw_bufp += strlen(gtp_rw_bufp);
            ret = 1;
        } else if (strncmp("qSupported", rsppkg, 10) == 0) {
#ifdef GTP_RB
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX,
                 "QStartNoAckMode+;ConditionalTracepoints+;"
                 "TracepointSource+;DisconnectedTracing+;"
                 "ReverseContinue+;ReverseStep+;"
#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,30))
                 "EnableDisableTracepoints+;"
#endif
                 "qXfer:traceframe-info:read+;");
#endif
#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX,
                 "QStartNoAckMode+;ConditionalTracepoints+;"
#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,30))
                 "EnableDisableTracepoints+;"
#endif
                 "TracepointSource+;DisconnectedTracing+;");
#endif
            gtp_rw_size += strlen(gtp_rw_bufp);
            gtp_rw_bufp += strlen(gtp_rw_bufp);
            ret = 1;
        }
#ifdef GTP_RB
        else if (strncmp("qXfer:traceframe-info:read::",
                   rsppkg, 28) == 0)
            ret = gtp_gdbrsp_qxfer_traceframe_info_read(rsppkg
                                    + 28);
#endif
        else if (strncmp("qRcmd,", rsppkg, 6) == 0)
            ret = gtp_gdbrsp_qRcmd(rsppkg + 6);
        else if (strncmp("qAttached", rsppkg, 9) == 0) {
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "1");
            gtp_rw_size += 1;
            gtp_rw_bufp += 1;
        }
        break;
    case 'S':
    case 'C':
        ret = -1;
        break;
    case 'b':
        rsppkg[0] = rsppkg[1];
        is_reverse = 1;
    case 's':
    case 'c':
        ret = gtp_gdbrsp_resume (rsppkg[0] == 's', is_reverse);
        break;
    case 'v':
        if (strncmp("vAttach;", rsppkg, 8) == 0) {
#ifdef GTP_RB
            if (gtp_replay_step_id)
                gtp_replay_reset();
#endif
            ret = gtp_gdbrsp_vAttach(rsppkg + 8);
        } else if (strncmp("vKill;", rsppkg, 7) == 0) {
#ifdef GTP_RB
            if (gtp_replay_step_id)
                gtp_replay_reset();
#endif
            /* XXX:  When we add more code to support trace
               user space program.  We need add more release
               code to this part.
               Release tracepoint for this tracepoint.  */
            ret = 0;
        }
        break;
    case 'D':
#ifdef GTP_RB
        if (gtp_replay_step_id)
            gtp_replay_reset();
#endif
        gtp_gdbrsp_D(rsppkg + 1);
        ret = 0;
        break;
    case 'H':
        ret = gtp_gdbrsp_H(rsppkg + 1);
        break;
    case 'Z':
    case 'z':
        if (rsppkg[1] == '0')
            ret = gtp_gdbrsp_breakpoint(rsppkg + 3,
                            (rsppkg[0] == 'Z'));
        break;
    }
switch_done:
    if (ret == 0) {
        snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "OK");
        gtp_rw_bufp += 2;
        gtp_rw_size += 2;
    } else if (ret &lt; 0) {
        snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "E%02x", -ret);
        gtp_rw_bufp += 3;
        gtp_rw_size += 3;
    }

    gtp_rw_bufp[0] = '#';
    csum = 0;
    for (i = 1; i &lt; gtp_rw_size + 1; i++)
        csum += gtp_rw_buf[i];
    gtp_rw_bufp[1] = INT2CHAR(csum &gt;&gt; 4);
    gtp_rw_bufp[2] = INT2CHAR(csum &amp; 0x0f);
    gtp_rw_bufp = gtp_rw_buf;
    gtp_rw_size += 4;

out:
    wake_up_interruptible_nr(&gt;p_rw_wq, 1);
error_out:
    up(&gt;p_rw_lock);
    return size;
}
</code></pre>

<p>我们可以看到根据接收到的Packet，分别调用了不同的handler来做处理，这里我们重点关注Tracepoint Packets，关于以QT开头的包，处理代码如下：</p>

<pre><code>static int
gtp_gdbrsp_QT(char *pkg)
{
    int ret = 1;

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_QT: %s\n", pkg);
#endif

    if (strcmp("init", pkg) == 0)
        ret = gtp_gdbrsp_qtinit();
    else if (strcmp("Stop", pkg) == 0)
        ret = gtp_gdbrsp_qtstop();
    else if (strcmp("Start", pkg) == 0)
        ret = gtp_gdbrsp_qtstart();
    else if (strncmp("DP:", pkg, 3) == 0)
        ret = gtp_gdbrsp_qtdp(pkg + 3);
    else if (strncmp("DPsrc:", pkg, 6) == 0)
        ret = gtp_gdbrsp_qtdpsrc(pkg + 6);
    else if (strncmp("Disconnected:", pkg, 13) == 0)
        ret = gtp_gdbrsp_qtdisconnected(pkg + 13);
    else if (strncmp("Buffer:", pkg, 7) == 0)
        ret = gtp_gdbrsp_qtbuffer(pkg + 7);
    else if (strncmp("Frame:", pkg, 6) == 0)
        ret = gtp_gdbrsp_qtframe(pkg + 6);
    else if (strncmp("ro:", pkg, 3) == 0)
        ret = gtp_gdbrsp_qtro(pkg + 3);
    else if (strncmp("DV:", pkg, 3) == 0)
        ret = gtp_gdbrsp_qtdv(pkg + 3);
#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,30))
    else if (strncmp("Enable:", pkg, 7) == 0)
        ret = gtp_gdbrsp_qtenable_qtdisable(pkg + 7, 1);
    else if (strncmp("Disable:", pkg, 8) == 0)
        ret = gtp_gdbrsp_qtenable_qtdisable(pkg + 8, 0);
#endif

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_QT: return %d\n", ret);
#endif

    return ret;
}
</code></pre>

<p>而以qT打头的包，处理的接口如下：</p>

<pre><code>static int
gtp_gdbrsp_qT(char *pkg)
{
    int ret = 1;

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_qT: %s\n", pkg);
#endif

    if (strcmp("Status", pkg) == 0)
        ret = gtp_gdbrsp_qtstatus();
    else if (strcmp("fP", pkg) == 0)
        ret = gtp_gdbrsp_qtfp();
    else if (strcmp("sP", pkg) == 0)
        ret = gtp_gdbrsp_qtsp();
    else if (strcmp("fV", pkg) == 0)
        ret = gtp_gdbrsp_qtfsv(1);
    else if (strcmp("sV", pkg) == 0)
        ret = gtp_gdbrsp_qtfsv(0);
    else if (strncmp("V:", pkg, 2) == 0)
        ret = gtp_gdbrsp_qtv(pkg + 2);

    return ret;
</code></pre>

<p>从以上接口可以看到，是一个dispatch的过程，KGTP首先判断接收到的GDB包属于哪一类包，之后分发，而对于一个类型的包，又细分很多子包，最终分发给具体的接口实现，拿上面为例，有如下一个流程：
<strong>gtp_write &ndash;> gtp_gdbrsp_QT &ndash;> gtp_gdbrsp_qtbuffer</strong>。</p>

<p>通过以上分析，我们已经在Packet层面对GDB和KGTP的通信有了深入的理解。</p>

<h4>4. KGTP中set-buffer-size的处理逻辑</h4>

<p>有了以上分析，在用户输入了以下指令：</p>

<pre><code>set remote trace buffer-size on
set trace-buffer-size xxx
</code></pre>

<p>之后会发生什么呢？</p>

<p>让我们分别测试一下。</p>

<p>（1）set trace-buffer-size 100</p>

<pre><code>Aug 03 11:00:08 localhost.localdomain kernel: gtp_write: QTBuffer:size:64
Aug 03 11:00:08 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:64
Aug 03 11:00:08 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 11:00:08 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:setting buffer size to 100
Aug 03 11:00:08 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 11:00:08 localhost.localdomain kernel: gtp_read
</code></pre>

<p>（2）set trace-buffer-size 1000000</p>

<pre><code>Aug 03 11:00:33 localhost.localdomain kernel: gtp_write: QTBuffer:size:f4240
Aug 03 11:00:33 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:f4240
Aug 03 11:00:33 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 11:00:33 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:setting buffer size to 1000000
Aug 03 11:00:33 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 11:00:33 localhost.localdomain kernel: gtp_read
</code></pre>

<p>（3）set trace-buffer-size -1</p>

<pre><code>Aug 03 11:00:18 localhost.localdomain kernel: gtp_write: QTBuffer:size:-1
Aug 03 11:00:18 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:-1
Aug 03 11:00:18 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 11:00:18 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:setting buffer size to 0
Aug 03 11:00:18 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 11:00:18 localhost.localdomain kernel: gtp_read
</code></pre>

<p>（4）set trace-buffer-size unlimited</p>

<pre><code>Aug 03 11:00:44 localhost.localdomain kernel: gtp_write: QTBuffer:size:-1
Aug 03 11:00:44 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:-1
Aug 03 11:00:44 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 11:00:44 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:setting buffer size to 0
Aug 03 11:00:44 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 11:00:44 localhost.localdomain kernel: gtp_read
</code></pre>

<p>可以看到，<code>This packet directs the target to make the trace buffer be of size size if possible. A value of -1 tells the target to use whatever size it prefers</code>.</p>

<p>也就是说，-1和unlimited等价，GDB告诉target可以使用自己认为合适的size，而给一个合理范围的正整数n，则会要求target使用的buffer size为n，单位是byte。</p>

<p>因此，当我们接到GDB发来的size为-1的包时，可以直接忽略掉，而收到normal size的包时，需要跟当前使用的buffer size作对比，然后做相应处理。</p>

<h4>5. KGTP中set-buffer-size的具体实现</h4>

<p>目前KGTP的set-buffer-size分支，已经实现了对size处理的逻辑，参考[6]，具体代码如下：</p>

<pre><code>static int
gtp_gdbrsp_qtbuffer(char *pkg)
{
#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_qtbuffer\n");
#endif

    // Handle QTBuffer:circular:value
    if (strncmp("circular:", pkg, 9) == 0) {
        ULONGEST setting;

        pkg += 9;
        if (pkg[0] == '\0')
            return -EINVAL;
        hex2ulongest(pkg, &amp;setting);

#ifdef GTP_FTRACE_RING_BUFFER
#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,38)) \
    || defined(GTP_SELF_RING_BUFFER)
        gtp_circular = (int)setting;
        if (gtp_frame)
            ring_buffer_change_overwrite(gtp_frame, (int)setting);
#else
        if (gtp_circular != (int)setting)
            gtp_circular_is_changed = 1;
#endif
#endif
        gtp_circular = (int)setting;

        return 0;
    }
    // Handle QTBuffer:size:size 
    else if (strncmp("size:", pkg, 5) == 0) {

        ULONGEST size;
        int unlimited_or_not;

        pkg += 5;

        if (pkg[0] == '\0')
            return -EINVAL;

        // The size may equal to -1, so compare the pkg with "-1"
        if((strncmp("-1", pkg, 2) == 0) &amp;&amp; (*(pkg + 2) == '\0')) {
            unlimited_or_not = 1;
        }

        if(unlimited_or_not == 1) {
            // The user wants KGTP to choose the right size
            // So we just ignore the request

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_qtbuffer:keep buffer size as the user tells KGTP to use unlimited size");
#endif

            return 0;
        }

        // User wants to change the buffer size
        hex2ulongest(pkg, &amp;size);

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_qtbuffer:setting buffer size to %ld\n", size);
#endif

        // Handle the new ringbuffer size blow
        // gtp_set_trace_buffer_size(size);

        return 0;
    }

    return 1;
}
</code></pre>

<p>让我们测试一下：</p>

<p>（1）set trace-buffer-size -1</p>

<pre><code>Aug 03 12:37:28 localhost.localdomain kernel: gtp_write: QTBuffer:size:-1
Aug 03 12:37:28 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:-1
Aug 03 12:37:28 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 12:37:28 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:keep buffer size as the user tells KGTP to use unlimited size
Aug 03 12:37:28 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 12:37:28 localhost.localdomain kernel: gtp_read
</code></pre>

<p>（2）set trace-buffer-size unlimited</p>

<pre><code>Aug 03 12:37:57 localhost.localdomain kernel: gtp_write: QTBuffer:size:-1
Aug 03 12:37:57 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:-1
Aug 03 12:37:57 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 12:37:57 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:keep buffer size as the user tells KGTP to use unlimited size
Aug 03 12:37:57 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 12:37:57 localhost.localdomain kernel: gtp_read
</code></pre>

<p>Bingo！目前已经正确地实现了对size的解析处理，接下来的工作是继续调研KGTP trace buffer的实现，并根据size大小做出调整。</p>

<h4>6. 参考链接</h4>

<ul>
<li>[1] <a href="http://blog.csdn.net/calmdownba/article/details/38174759">http://blog.csdn.net/calmdownba/article/details/38174759</a></li>
<li>[2] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Packets.html#Packets">https://sourceware.org/gdb/current/onlinedocs/gdb/Packets.html#Packets</a></li>
<li>[3] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Remote-Protocol.html#Remote-Protocol">https://sourceware.org/gdb/current/onlinedocs/gdb/Remote-Protocol.html#Remote-Protocol</a></li>
<li>[4] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html</a></li>
<li>[5] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html</a></li>
<li>[6] <a href="https://code.csdn.net/Calmdownba/kgtp/tree/set-buffer-size">https://code.csdn.net/Calmdownba/kgtp/tree/set-buffer-size</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KGTP中增加对GDB命令“set Trace-buffer-size”的支持 - Week 3]]></title>
    <link href="http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-3/"/>
    <updated>2014-07-27T04:34:52-07:00</updated>
    <id>http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-3</id>
    <content type="html"><![CDATA[<h3>CSDN开源夏令营 &ndash; 第三周工作总结</h3>

<p>这一周主要实现了“set trace-buffer-size”实现的数据通信部分，即完成了GDB和KGTP的数据交互部分，下面简单分析一下实现。在说代码实现之前，还是简单地回顾一下，如何摸清KGTP的脉络。</p>

<h4>1. 如何跟踪KGTP</h4>

<p>我的平台是Fedora，步骤如下：</p>

<pre><code>make D=1
sudo insmod gtp.ko
sudo gdb /usr/lib/debug/lib/modules/3.14.8-200.fc20.x86_64/vmlinux -ex 'target remote /sys/kernel/debug/gtp'
</code></pre>

<!--more-->


<p>此时，进入了gdb的console，可以通过gdb的commands和KGTP通信了。观察KGTP的一个重要的手段则是看printk的信息，由于编译时使用了“make D=1”，因此对应KGTP的代码，比如：</p>

<pre><code> #ifdef GTP_DEBUG                                                                                            
     printk(GTP_DEBUG "gtp_gdbrsp_qtbuffer\n");                                                              
 #endif    
</code></pre>

<p>查看这些的方式则是使用“journalctl -k”，方便起见可以只查看末尾的部分信息，比如“journalctl -k -n 100”，在我的本地输出的部分信息如下：</p>

<pre><code>Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: qAttached
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: qOffsets
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: g
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: m0,1
Jul 27 06:07:29 localhost.localdomain kernel: gtp_gdbrsp_m: addr = 0x0 len = 1
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: m0,1
Jul 27 06:07:29 localhost.localdomain kernel: gtp_gdbrsp_m: addr = 0x0 len = 1
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: qSymbol::
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: qTStatus
Jul 27 06:07:29 localhost.localdomain kernel: gtp_gdbrsp_qT: Status
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: qTfP
Jul 27 06:07:29 localhost.localdomain kernel: gtp_gdbrsp_qT: fP
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
</code></pre>

<p>根据以上信息，可以顺藤摸瓜找到相应被调用的函数，从而屡清楚程序的执行逻辑，这对于理解KGTP的工作原理是非常有帮助的。关于journalctl[1]的使用，请自行“man journalctl”。在非systemd[2]的系统下，可能还需要通过“less /var/log/”这样的方式查看内核的输出，根据你使用的Linux随机应变即可。</p>

<h4>2. GDB和KGTP的通信实现</h4>

<p>利用GDBRSP[3]，即GDB Remote Serial Protocol，GDB远程串行通信协议。关于Remote Serial Protocol，可以参考[4]。简单来说，用于GDB远程调试发包，但是也支持File I/O和Console[5]，而KGTP正是利用了GDBRSP对于File I/O的支持，完成GDB和KGTP的通信，在接受到GDB发送的Packet后，KGTP进行解析。而通信的介质则是通过debugfs或者其他kernel space和user space进行数据交换的接口进行的。</p>

<p>具体的实现，参考gtp.c的函数 <code>gtp_init</code>，部分代码如下：</p>

<pre><code> gtp_dir = debugfs_create_file("gtp", S_IRUSR | S_IWUSR, NULL,
                   NULL, &amp;gtp_operations);
 if (gtp_dir == NULL || gtp_dir == ERR_PTR(-ENODEV)) {
     gtp_dir = NULL;
     goto out;
 }
 gtpframe_dir = debugfs_create_file("gtpframe", S_IRUSR, NULL,
                    NULL, &amp;gtpframe_operations);
 if (gtpframe_dir == NULL || gtpframe_dir == ERR_PTR(-ENODEV)) {
     gtpframe_dir = NULL;
     goto out;
 }
</code></pre>

<p>可以看到，使用DebugFS，建立了相应的文件节点，比如gtp，gtpframe，并且注册了相应的file operations，比如<code>gtp_oprations</code>，<code>gtpframe_operations</code>。</p>

<p>拿前者为例，声明的代码如下：</p>

<pre><code>static const struct file_operations gtp_operations = {
     .owner      = THIS_MODULE,
     .open       = gtp_open,
     .release    = gtp_release,
 #if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,35))
     .ioctl      = gtp_ioctl,
 #else
     .unlocked_ioctl = gtp_ioctl,
     .compat_ioctl   = gtp_ioctl,
 #endif
     .read       = gtp_read,
     .write      = gtp_write,
     .poll       = gtp_poll,
 };
</code></pre>

<p>而这其中最核心的则是<code>gtp_read</code>和<code>gtp_write</code>，其中<code>gtp_read</code>，用于GDB从KGTP读取数据（<strong>copy_to_user</strong>），gtp_write，则是KGTP从GDB接收数据（<strong>copy_from_user</strong>）。具体的代码，这里就不贴了，大家可以自行分析。</p>

<p>GDB和KGTP通过GDBRSP关联，通过执行<code>target remote /sys/kernel/debug/gtp</code>实现。</p>

<h4>3. 添加“set-trace-buffer-size”的通信支持</h4>

<p>有了以上的理论分析和准备，我们就可以着手实现“set trace-buffer-size”命令的解析了。首先，我们需要知道这个命令对应的GDBRSP的Query Packet以及KGTP利用哪个函数对其进行解析。通过[6]和[7]，我们得知如下信息：</p>

<pre><code>set circular-trace-buffer on
set circular-trace-buffer off
Choose whether a tracing run should use a linear or circular buffer for trace data. A linear buffer will not lose any trace data, but may fill up prematurely, while a circular buffer will discard old trace data, but it will have always room for the latest tracepoint hits.

show circular-trace-buffer
Show the current choice for the trace buffer. Note that this may not match the agent’s current buffer handling, nor is it guaranteed to match the setting that might have been in effect during a past run, for instance if you are looking at frames from a trace file.

set trace-buffer-size n
set trace-buffer-size unlimited
Request that the target use a trace buffer of n bytes. Not all targets will honor the request; they may have a compiled-in size for the trace buffer, or some other limitation. Set to a value of unlimited or -1 to let the target use whatever size it likes. This is also the default.

show trace-buffer-size
Show the current requested size for the trace buffer. Note that this will only match the actual size if the target supports size-setting, and was able to handle the requested size. For instance, if the target can only change buffer size between runs, this variable will not reflect the change until the next run starts. Use tstatus to get a report of the actual buffer size.


‘QTBuffer:circular:value’
This packet directs the target to use a circular trace buffer if value is 1, or a linear buffer if the value is 0.

‘QTBuffer:size:size’
This packet directs the target to make the trace buffer be of size size if possible. A value of -1 tells the target to use whatever size it prefers.
</code></pre>

<p>嗯，有线索了，GDB执行相应地指令，则会通过GDBRSP向KGTP发送相应的Query Packet，注意到“circular-trace-buffer”和“trace-buffer-size”的Packet的格式相同。关于GDB的General Query Packet，参考[8]。<strong>Packets starting with ‘q’ are general query packets; packets starting with ‘Q’ are general set packets. General query and set packets are a semi-unified form for retrieving and sending information to and from the stub.</strong></p>

<p>因此，参考“circular-trace-buffer”的实现是一个很好的突破口，所幸的是，KGTP已经实现了对其的支持。</p>

<h4>4. 添加“set trace-buffer-size”的具体实现</h4>

<p>根据以上分析，我们很快找到了两个关键函数，“gtp_gdbrsp_QT  ”和“gtp_gdbrsp_qtbuffer”。OK，添加对“set trace-buffer-size”的解析，代码如下：</p>

<pre><code>static int
gtp_gdbrsp_qtbuffer(char *pkg)
{
#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_qtbuffer\n");
#endif

    // Handle QTBuffer:circular:value
    if (strncmp("circular:", pkg, 9) == 0) {
        ULONGEST setting;

        pkg += 9;
        if (pkg[0] == '\0')
            return -EINVAL;
        hex2ulongest(pkg, &amp;setting);

#ifdef GTP_FTRACE_RING_BUFFER
#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,38)) \
    || defined(GTP_SELF_RING_BUFFER)
        gtp_circular = (int)setting;
        if (gtp_frame)
            ring_buffer_change_overwrite(gtp_frame, (int)setting);
#else
        if (gtp_circular != (int)setting)
            gtp_circular_is_changed = 1;
#endif
#endif
        gtp_circular = (int)setting;

        return 0;
    }
    // Handle QTBuffer:size:size 
    else if (strncmp("size:", pkg, 5) == 0) {

        ULONGEST size;

        pkg += 5;

        if (pkg[0] == '\0')
            return -EINVAL;
        hex2ulongest(pkg, &amp;size);

        // Handle the new ringbuffer size blow

        return 0;
    }

    return 1;
}
</code></pre>

<p>重新编译，安装模块，然后在GDB中输入“set trace-buffer-size 100”，注意这里的100是十进制的，看下“journalctl -k”的输出，啥也没有。怎么回事，上面分析的不是挺美好的吗？经过几次尝试未果，把问题定位在了GDB对于Remote Packet的处理，不会是没有enable吧？</p>

<p>查看文档[9]，果然，应该使用<code>set remote set-buffer-size on</code>先使能，否则应该是直接被gdbrsp丢掉了。OK，使用<code>set trace-buffer-size 100</code>，输出：</p>

<pre><code>Jul 27 07:18:45 localhost.localdomain kernel: gtp_write: QTBuffer:size:64
Jul 27 07:18:45 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:64
Jul 27 07:18:45 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Jul 27 07:18:45 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Jul 27 07:18:45 localhost.localdomain kernel: gtp_read
</code></pre>

<p>而使用<code>set trace-buffer-size unlimited</code>，输出：</p>

<pre><code>Jul 27 07:19:53 localhost.localdomain kernel: gtp_write: QTBuffer:size:-1
Jul 27 07:19:53 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:-1
Jul 27 07:19:53 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Jul 27 07:19:53 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Jul 27 07:19:53 localhost.localdomain kernel: gtp_read
</code></pre>

<p>OK，至此对于“set trace-buffer-size”的通信支持就完成了，接下来需要根据用户设置的size对trace buffer做出调整，接下来的文章会说到如何实现。</p>

<h4>5. 参考链接</h4>

<ul>
<li> [1] <a href="http://www.freedesktop.org/software/systemd/man/journalctl.html">http://www.freedesktop.org/software/systemd/man/journalctl.html</a></li>
<li> [2] <a href="https://wiki.archlinux.org/index.php/systemd">https://wiki.archlinux.org/index.php/systemd</a></li>
<li> [3] <a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html</a></li>
<li> [4] <a href="http://blog.csdn.net/hmsiwtv/article/details/8759129">http://blog.csdn.net/hmsiwtv/article/details/8759129</a></li>
<li> [5] <a href="https://sourceware.org/gdb/onlinedocs/gdb/File_002dI_002fO-Remote-Protocol-Extension.html#File_002dI_002fO-Remote-Protocol-Extension">https://sourceware.org/gdb/onlinedocs/gdb/File_002dI_002fO-Remote-Protocol-Extension.html#File_002dI_002fO-Remote-Protocol-Extension</a></li>
<li> [6] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html</a></li>
<li> [7] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html</a></li>
<li> [8] <a href="https://www.sourceware.org/gdb/onlinedocs/gdb/General-Query-Packets.html#General-Query-Packets">https://www.sourceware.org/gdb/onlinedocs/gdb/General-Query-Packets.html#General-Query-Packets</a></li>
<li> [9] <a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Configuration.html">https://sourceware.org/gdb/onlinedocs/gdb/Remote-Configuration.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KGTP中增加对GDB命令“set Trace-buffer-size”的支持 - Week 2]]></title>
    <link href="http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-2/"/>
    <updated>2014-07-27T04:34:48-07:00</updated>
    <id>http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-2</id>
    <content type="html"><![CDATA[<h3>CSDN开源夏令营 &ndash; 第二周工作总结</h3>

<p>这一周在上一周对整体框架的认识和理解之上，开始全面地阅读KGTP的源代码，理解了梗概，很多细节需要再仔细研读，主要参考是其代码仓库：[1]。</p>

<h4>1. KGTP的核心代码文件</h4>

<p>毫无疑问，KGTP最精髓的代码都在gtp.c文件中，约13500行代码，这其中包括了与GDB的通信，具体Query Packets的处理，Trace Points的注册和删除，事件的触发，硬件断点的设置和处理，等几乎所有的KGTP核心事务。在短短1万多行代码中，体现了几乎所有Linux Kernel开发过程中会用到的features，SMP的支持，Linux的list实现，锁和同步，工作队列，tasklet，硬件和软件中断，等等。</p>

<!--more-->


<p>其它辅助文件则有：</p>

<ul>
<li> <code>gtp_rb.c</code>      KGTP自己实现的一套Ring Buffer（默认使用）</li>
<li> <code>perf_event.c</code>  Perf的核心实现，里面也实现Ring Buffer</li>
<li> <code>ring_buffer.c</code> Linux内核为Trace的infrastructure提供的统一的Ring Buffer实现（比如Ftrace）</li>
</ul>


<h4>2. KGTP核心功能实现的源码分析</h4>

<p>按照数据通信流程，<strong>GDB ——>   GDBRSP ——> SYSFS ——> KGTP ——> Kernel</strong>，简单分析如下：</p>

<p><code>GDBRSP</code>是Remote Serial Protocol，用于GDB远程调试发包，但是也支持File I/O和Console，而KGTP正是利用了GDBRSP对于File I/O的支持，完成GDB和KGTP的通信，在接受到GDB发送的Packet后，KGTP进行解析。而通信的介质则是通过debugfs或者其他kernel space和user space进行数据交换的接口进行（参考[2]）。</p>

<p>KGTP接收到了GDB的指令后，基于Kprobes和Uprobes进行内核和用户应用程序的trace，step和watch可以基于hardware-breakpoints实现。</p>

<p>KGTP自己维护了一个ring buffer的，用于Trace Frame的存储，查询及dump。</p>

<h5>（1）KGTP和GDB的通信</h5>

<p>核心函数：</p>

<ul>
<li> <code>gtp_init</code>    建立对应的ProcFS或者DebugFS文件结点</li>
</ul>


<p>以下函数利用GDBRSP完成GDB和KGTP基于packet的通信：</p>

<ul>
<li> <code>gtp_open</code></li>
<li> <code>gtp_release</code></li>
<li> <code>gtp_ioctl</code></li>
<li> <code>gtp_write</code></li>
<li> <code>gtp_read</code></li>
<li> <code>gtp_poll</code></li>
</ul>


<h5>（2）KGTP对GDB数据包的处理</h5>

<p><code>gtp_gdbrsp_*</code> 系列函数完成了对GDB数据包的解析和处理。</p>

<p>比如：</p>

<ul>
<li> <code>gtp_gdbrsp_QT</code>        处理QT的packet</li>
<li> <code>gtp_gdbrsp_qtstart</code>   Start Trace Experiments，注册kprobe，uprobe以及watchpoints，hardware breakpoints等，并分配存储空间</li>
<li> <code>gtp_qdbrsp_qtstop</code>    Stop Trace Experiments，flush work queue，tasklet_kill，以及unregister在qtstart注册的所有probe points和一些回调函数</li>
</ul>


<p>参考的话，就是GDB的官方手册了，比如：</p>

<p>GDB的<a href="https://www.sourceware.org/gdb/onlinedocs/gdb/General-Query-Packets.html">Query Packet</a>.
Packets starting with ‘q’ are general query packets; packets starting with ‘Q’ are general set packets. General query and set packets are a semi-unified form for retrieving and sending information to and from the stub.</p>

<h5>（3）Tracepoints和Breakpoints的注册和删除</h5>

<ul>
<li> <code>gtp_uprobe_register</code></li>
<li> <code>gtp_register_hwb</code></li>
<li> <code>gtp_unregister_hwb</code></li>
</ul>


<h5>（4）TSV的处理</h5>

<p><code>gtp_var_*</code></p>

<p>可以重点看一下<code>gtp_var_special_add_all</code>。</p>

<h5>（5）Ring Buffer的处理</h5>

<p>这里后续再详细分析，Ring Buffer的实现也是KGTP的核心之一。</p>

<h4>3. 阅读源码小技巧&amp;问题总结</h4>

<p>参考<code>LXR</code>[3]，直接使用<code>Identifier Search</code>[4]，遇到不明白的宏定义，函数定义，都可以直接到Linux源码中一探究竟。</p>

<p>以下是我阅读代码过程遇到的一些问题总结：</p>

<p>（1）EXPORT_SYMBOL</p>

<p><a href="http://stackoverflow.com/questions/9836467/whats-meaning-of-export-symbol-in-linux-kernel-code">http://stackoverflow.com/questions/9836467/whats-meaning-of-export-symbol-in-linux-kernel-code</a></p>

<p><a href="http://www.linux.com/learn/linux-training/31161-the-kernel-newbie-corner-kernel-symbols-whats-available-to-your-module-what-isnt">http://www.linux.com/learn/linux-training/31161-the-kernel-newbie-corner-kernel-symbols-whats-available-to-your-module-what-isnt</a></p>

<p>（2）container_of</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/kernel.h#L833">http://lxr.free-electrons.com/source/include/linux/kernel.h#L833</a></p>

<pre><code>/**
827  * container_of - cast a member of a structure out to the containing structure
828  * @ptr:        the pointer to the member.
829  * @type:       the type of the container struct this is embedded in.
830  * @member:     the name of the member within the struct.
831  *
832  */
833 #definecontainer_of(ptr,type, member) ({                      \
834         const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \
835         (type *)( (char *)__mptr - offsetof(type,member) );})
</code></pre>

<p>（3）kzalloc</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/slab.h#L649">http://lxr.free-electrons.com/source/include/linux/slab.h#L649</a></p>

<p>（4）kmalloc</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/slab.h#L452">http://lxr.free-electrons.com/source/include/linux/slab.h#L452</a></p>

<p>（5）list</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/list.h">http://lxr.free-electrons.com/source/include/linux/list.h</a></p>

<p>（6）INIT_WORK</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/workqueue.h">http://lxr.free-electrons.com/source/include/linux/workqueue.h</a></p>

<p>（7）vfree</p>

<p><a href="http://lxr.free-electrons.com/source/mm/vmalloc.c#L1490">http://lxr.free-electrons.com/source/mm/vmalloc.c#L1490</a></p>

<p>（8）preempt_disable</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/preempt.h#L38">http://lxr.free-electrons.com/source/include/linux/preempt.h#L38</a></p>

<p>（9）barrier</p>

<p><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">https://www.kernel.org/doc/Documentation/memory-barriers.txt</a></p>

<p>（10）local_irq_save</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/irqflags.h#L93">http://lxr.free-electrons.com/source/include/linux/irqflags.h#L93</a></p>

<p>（11）notifier_block</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/notifier.h#L53">http://lxr.free-electrons.com/source/include/linux/notifier.h#L53</a></p>

<p>（12）flush_workqueue</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/workqueue.c#L2641">http://lxr.free-electrons.com/source/kernel/workqueue.c#L2641</a></p>

<p>（13）tasklet_kill</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/softirq.c#L566">http://lxr.free-electrons.com/source/kernel/softirq.c#L566</a></p>

<p>（14）unregister_wide_hw_breakpoint</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/events/hw_breakpoint.c#L536">http://lxr.free-electrons.com/source/kernel/events/hw_breakpoint.c#L536</a></p>

<p>（15）unregister_kprobe</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/kprobes.c#L1668">http://lxr.free-electrons.com/source/kernel/kprobes.c#L1668</a></p>

<p>（16）wake_up_interruptible_nr</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/sched/wait.c#L88">http://lxr.free-electrons.com/source/kernel/sched/wait.c#L88</a></p>

<p>（17）queue_work</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/sched/wait.c#L88">http://lxr.free-electrons.com/source/kernel/sched/wait.c#L88</a></p>

<p>（18）rcu_read_lock</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/rcupdate.h#L798">http://lxr.free-electrons.com/source/include/linux/rcupdate.h#L798</a></p>

<p>（19）tasklet_init</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/softirq.c#L555">http://lxr.free-electrons.com/source/kernel/softirq.c#L555</a></p>

<p>（20）IPI</p>

<p><a href="http://en.wikipedia.org/wiki/Inter-processor_interrupt">http://en.wikipedia.org/wiki/Inter-processor_interrupt</a></p>

<p>（21）register_die_notifier</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/notifier.c#L544">http://lxr.free-electrons.com/source/kernel/notifier.c#L544</a></p>

<p>（22）EBUSY</p>

<p><a href="http://lxr.free-electrons.com/source/include/uapi/asm-generic/errno-base.h#L19">http://lxr.free-electrons.com/source/include/uapi/asm-generic/errno-base.h#L19</a></p>

<h4>4. KGTP的调试&amp;源码注释</h4>

<p>编译KGTP的时候添加D=1，便以debug的方式编译，在Fedora下可以通过journalctl -k查看其输出，其中-k是指过滤Kernel信息。其它系统下可能是在/var/log之类的文件查看，总之KGTP通过内核接口printfk输出，视具体的系统不同，查看内核信息的方式也会有变化。</p>

<p>关于有注释的代码，请看[5]。</p>

<h4>5. 参考链接</h4>

<ul>
<li> [1] <a href="https://github.com/teawater/kgtp">https://github.com/teawater/kgtp</a></li>
<li> [2] <a href="http://people.ee.ethz.ch/~arkeller/linux/multi/kernel_user_space_howto.html#toc1">http://people.ee.ethz.ch/~arkeller/linux/multi/kernel_user_space_howto.html#toc1</a></li>
<li> [3] <a href="http://lxr.free-electrons.com">http://lxr.free-electrons.com</a></li>
<li> [4] <a href="http://lxr.free-electrons.com/ident">http://lxr.free-electrons.com/ident</a></li>
<li> [5] <a href="https://code.csdn.net/Calmdownba/kgtp/tree/comments-from-scratch">https://code.csdn.net/Calmdownba/kgtp/tree/comments-from-scratch</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KGTP中增加对GDB命令“set Trace-buffer-size”的支持 - Week 1]]></title>
    <link href="http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-1/"/>
    <updated>2014-07-27T04:34:45-07:00</updated>
    <id>http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-1</id>
    <content type="html"><![CDATA[<h3>CSDN开源夏令营 &ndash; 第一周工作总结</h3>

<p>这一周主要对KGTP的实现进行了简单的熟悉和分析，主要参考的资料在：[1]。</p>

<h4>1.什么是KGTP</h4>

<p>T大把KGTP称为Linux内核中的GDB快刀，其全称是Linux kernel GDB tracepoint module，是一个灵活轻量级实时的Linux调试器和跟踪器。</p>

<p>Linux的tracer infrastructure五花八门，包括Ftrace，Utrace等，建议大家参考一下这篇paper，【Ptrace, Utrace, Uprobes: Lightweight, Dynamic Tracing of User Apps】，下载链接在：[2]。Tracer在收集信息的时候不停止Linux内核，但是不能被GDB控制。</p>

<!--more-->


<p>而在调试Linux内核的时候，我们也有很多选择，比如KDB，KGDB等，Debugger将停止Linux内核，但是可以被GDB控制。</p>

<p>那么KGTP做了什么事情呢？Yes，作为Tracer和Debugger的一个桥梁，从而做到不停止Linux内核，且可以被本地或者远程的GDB控制。</p>

<p>目前，KGTP支持X86-32，X86-64，MIPS和ARM，支持Linux内核2.6.18到upstream，直接Android（因为Android底层仍然是Linux Kernel）。</p>

<h4>2. KGTP的实现</h4>

<p>KGTP的大部分trace功能基于Kprobe，而用户态应用程序的trace功能则依赖Uprobe，对于使用Kprobe的情况，使用Kprobes-optimization还可提高Kprobe的速度。</p>

<p>作为Debugger和Tracer之间的桥梁，KGTP通过GDB的RSP协议与GDB通信，完成数据的交换和用户命令的解析，具体的信息可以看GDB的文档，比如：<a href="https://www.sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">GDB Remote-Protocol</a>。KGTP内核态和用户态的数据交换，通过DebugFS或者ProcFS暴露给用户态的GDB。在接收到相关的GDB命令数据包后，完成相关的解析工作，设置对应的Tracepoint，在用户开始trace后（tstart），开始在Ring Buffer采集数据，结束后（tstop）可以供用户查看（tfind）。</p>

<p>KGTP作为一个内核module存在，只需要编译KGTP后insmod，而不需要重新编译内核，因此非常灵活，当不需要KGTP的时候，直接rmmod即可。</p>

<p>KGTP的数据分析主要使用GDB，因此代码中不需要很多数据分析的部分，核心源代码文件gtp.c，仅有13000行左右。</p>

<p>总结起来，KGTP是一个灵活且轻量级的实现，可以实时地对Linux进行跟踪和调试，这对于线上服务器的问题处理是非常有用的。</p>

<h4>3. KGTP的hack需要具备哪些知识</h4>

<p>C语言功底+一定的Linux内核开发基础，具体的点总结如下：</p>

<ul>
<li> （1）Linux内核的同步机制（锁，信号量等）</li>
<li> （2）字符驱动程序的实现原理，主要是GDB和KGTP的通信需要用到</li>
<li> （3）Linux内核module的编写，因此KGTP是以一个module的形式存在的</li>
<li> （4）Linux内核的tasklet和workqueue，KGTP的后台进程是一个守护进程gtpd</li>
<li> （5）Ring buffer的实现，Linux内核trace的RB的实现以及KGTP自身RB的实现</li>
<li> （6）Linux tracer的实现原理，因为KGTP是基于Kprobe和Uprobe实现的</li>
<li> （7）GDB的基本原理，尤其是GDBRSP</li>
</ul>


<h4>4. 如何增加对GDB命令“set trace-buffer-size”的支持</h4>

<ul>
<li> （1）实现命令包的解析，参考[3][4]</li>
<li> （2）实现Ring Buffer数据的拷贝和其他处理（主要针对新分配缓冲区小于原有缓冲区的情况）</li>
</ul>


<h4>5. 如何部署KGTP</h4>

<p>强烈建议采用“一键安装”的方式，KGTP提供了部署脚本[kgtp.py]，十分方便。</p>

<p>Kernel需要相应地debug info，因此如果是自己编译内核，则需要：</p>

<pre><code>General setup —&gt;
[*] Kprobes
[*] Enable loadable module support —&gt;
Kernel hacking —&gt;
[*] Debug Filesystem
[*] Compile the kernel with debug info
</code></pre>

<p>如果是Distro，需要安装Linux内核调试镜像和Linux内核源码包和开发包。</p>

<p>只有这样，Kernel才能被GDB加载调试。</p>

<p>以Fedora为例，当完成了以上步骤后，直接</p>

<pre><code>sudo gdb /usr/lib/debug/lib/modules/3.14.8-200.fc20.x86_64/vmlinux -ex 'target remote /sys/kernel/debug/gtp'
</code></pre>

<p>根据使用内核版本的不同，加载的kernel image路径会有稍许区别，比如上面的<code>3.14.8-200.fc20.x86_64</code>。</p>

<p>至此，部署完毕。</p>

<h4>6. 如何使用KGTP</h4>

<p>请参考KGTP的使用手册，具体链接见：[5]和[6]。</p>

<h4>7. 参考链接</h4>

<ul>
<li> [1] <a href="http://teawater.github.io/kgtp/index.html">http://teawater.github.io/kgtp/index.html</a></li>
<li> [2] <a href="http://kernel.org/doc/ols/2007/ols2007v1-pages-215-224.pdf">http://kernel.org/doc/ols/2007/ols2007v1-pages-215-224.pdf</a></li>
<li> [3] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html</a></li>
<li> [4] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html</a></li>
<li> [5] <a href="http://teawater.github.io/kgtp/kgtp.html">http://teawater.github.io/kgtp/kgtp.html</a></li>
<li> [6] <a href="http://teawater.github.io/kgtp/kgtpcn.html">http://teawater.github.io/kgtp/kgtpcn.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Review of Raspberry Pi Robotic Projects - From a Technical Perspective]]></title>
    <link href="http://hustcalm.me/blog/2014/06/21/review-of-raspberry-pi-robotic-projects-from-a-technical-perspective/"/>
    <updated>2014-06-21T04:15:15-07:00</updated>
    <id>http://hustcalm.me/blog/2014/06/21/review-of-raspberry-pi-robotic-projects-from-a-technical-perspective</id>
    <content type="html"><![CDATA[<p>After being the reviewer for the <a href="http://hustcalm.me/blog/2014/02/10/review-of-beaglebone-robotic-projects-from-a-technical-perspective/">BeagleBone Robotic Projects</a>, I&rsquo;m honored to be the reviewer for another book about robotic projects named <a href="http://bit.ly/1hrlCQP">Raspberry Pi Robotic Projects</a>. I will go no further to talk about the differences about <code>BeagleBone</code> and <code>Raspberry Pi</code>, all I know is that they are both cool and amazing. To start to play with <code>Raspberry Pi</code>, I suggest that you
can list the book <a href="http://bit.ly/1hrlCQP">Raspberry Pi Robotics Projects</a> as an option.</p>

<p>In this post, I will give you a very quick overview of the book and tell why it&rsquo;s worth it.</p>

<!--more-->


<h4>Getting Started with Raspberry Pi</h4>

<p>Have no idea what is really <code>Raspberry Pi</code>? Well, just treat it as your <code>Mini Computer</code>. The truth is, it got almost everything what a PC should be equipped with. What&rsquo;s more, it runs Linux which means you can do tons of things with it!</p>

<p>Yes, yes, <code>Raspberry Pi</code> is leading the <code>open hardware community</code> somehow, people design, manufacture, develop and play. Geeks use it for their geek life!</p>

<p>In <strong>chapter 1</strong>, you will be informed the hardware and software of <code>Raspberry Pi</code> and begin to be friends with her.</p>

<h4>Programming Raspberry Pi</h4>

<p>As you want to make <code>Raspberry Pi</code> do something really amazing, you should know how to talk to her. Well, you program to talk. So in <strong>chapter 2</strong>, we will show you how to get comfortable with the way <code>talking(programming)</code>. Besides to knowing <code>Linux</code>, use <code>Python</code> and <code>C/C++</code> is cool:&ndash;)</p>

<h4>Providing Speech Input and Output</h4>

<p>What? You want to talk to her, really. I mean by <code>speaking</code>. Well, that should not be problem. Let&rsquo;s give our robot <code>ears</code> and <code>mouth</code>. <strong>Chapter 3</strong> will show you how to use <code>PocketSphinx</code> to accept your voice commands and utilize <code>Espeak</code> to make <code>Raspberry Pi</code> talk in a robot voice.</p>

<h4>Adding Vision to Raspberry Pi</h4>

<p>How can a beautiful girl be blind! So to make <code>Rasberry Pi</code> see the amazing world, <strong>chapter 4</strong> will tell you how to connect the USB cemara to <code>Raspberry Pi</code> and begin to use <code>OpenCV</code>, which is a fully featured vision library to detect colored objects.</p>

<h4>Creating Mobile Robots on Wheels</h4>

<p>Let&rsquo;s roll! To see the beatiful world around, we need to make our robot able to move. <strong>Chapter 5</strong> will show you how to add motor controller to <code>Raspberry Pi</code> and let her run at free will.</p>

<h4>Making the Unit Very Mobile &ndash; Controlling the Movement of a Robot with Legs</h4>

<p>A girl should really walk, doesn&rsquo;t it? No problem, <strong>chapter 6</strong> tells how to get started with <code>servos</code> and make your mobile platform truly mobile just as a person.</p>

<h4>Avoiding Obstacles Using Sensors</h4>

<p>Oh, there is a wall in front, danger! Don&rsquo;t worry, our <code>Raspberry Pi</code> knows everything and will avoid it easily. <strong>Chapter 7</strong> shows how to use an <code>infrared sensor</code> and <code>USB sonar sensor</code> with <code>Raspberry Pi</code>, also how to use a <code>servo</code> to move a single sensor to make our sening range large enough.</p>

<h4>Going Truly Mobile &ndash; The Remote Control of Your Robot</h4>

<p>You will not always be around with your <code>Raspberry Pi</code>, right? To make sure your <code>Pi</code> is always with you, <strong>Chapter 8</strong> demonstrates how to connect wireless devices to <code>Pi</code> thus enabling us to talk to her remotely. Use a <code>wireless USB keyboard</code>, or <code>a wireless LAN</code> or <code>a ZigBee device</code>, choose as you like.</p>

<h4>Using a GPS Receiver to Locate Your Robot</h4>

<p>No one wants to be told that his <code>Raspberry Pi</code> is lost. Fortunately, we got <code>GPS</code> nowadays for almost free. Connecting <code>Raspberry Pi</code> to a <code>GPS</code> device and accessing the <code>GPS</code> programmatically is mainly covered in <strong>chapter 9</strong>.</p>

<h4>System Dynamics</h4>

<p>Get tired with so much coding for each dedicated task? <strong>Chaper 10</strong> will free you from hell by creating a general control structure. Also you can enable complex functionalities by using the structure of the <code>Robot Operating System</code>.</p>

<h4>By Land, Sea, and Air</h4>

<p>Maybe you don&rsquo;t just want a <code>Raspbery Pi</code>, you really want is a <code>Quadrotor</code>, or a <code>submarine</code> or a <code>mini ship</code>! Nothing is impossible, <strong>Chapter 11</strong> will be a good starting point to creat something really amazing.</p>

<p>I hope that you like <code>Raspberry Pi</code> and the book will do some good. Happy playing and hakcing with <code>Raspberry Pi</code>!!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Is Socket Anyway?]]></title>
    <link href="http://hustcalm.me/blog/2014/04/17/what-is-socket-anyway/"/>
    <updated>2014-04-17T06:05:06-07:00</updated>
    <id>http://hustcalm.me/blog/2014/04/17/what-is-socket-anyway</id>
    <content type="html"><![CDATA[<p>I bet you&rsquo;ve heard of <code>socket</code> for a while, but do you really know what is a <code>socket</code>?</p>

<p>This post is a quick getting-started for figuring out the basic concepts of socket and hopefully enpowers you to begin writing simple network programming snippets. It aims to bootstrap your understanding to socket and network programming and serves as a good starting point to truth. From definition to practice and deep into research, let&rsquo;s start the venture!</p>

<!--more-->


<h2>The definition</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley sockets</a></li>
</ul>


<p>Let history and standards tell everything.</p>

<h2>Unix or Internet</h2>

<ul>
<li><a href="http://lists.freebsd.org/pipermail/freebsd-performance/2005-February/001143.html">unix domain sockets vs. internet sockets</a></li>
</ul>


<p>See what the freebsd gurus say.</p>

<h2>Unix socket deeper</h2>

<ul>
<li><a href="http://www.thomasstover.com/uds.html">Demystifying Unix Domain Sockets</a></li>
</ul>


<p>Code tells the truth.</p>

<h2>Network Programming Go</h2>

<ul>
<li><a href="http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html">Beej&rsquo;s Guide to Network Programming Using Internet Sockets</a></li>
</ul>


<p>Practices make best.</p>

<h2>What&rsquo;s Next</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/176409/how-to-build-a-simple-http-server-in-c">How to Build a simple HTTP server in C</a></li>
</ul>


<p>Wonder how to implement a HTTP server, like <code>Apache</code> or <code>Nginx</code>, you&rsquo;d better implement a simple, stupid but your own one.</p>

<ul>
<li><a href="http://www.kegel.com/c10k.html">The C10K problem</a></li>
</ul>


<p>Well, this is really where it hurts. Catch up with the paper, conquer it or give up early!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build PTAM on Fedora 20 the Easy Way - 10 Minutes Tutorial]]></title>
    <link href="http://hustcalm.me/blog/2014/04/17/build-ptam-on-fedora-20-the-easy-way-10-minutes-tutorial/"/>
    <updated>2014-04-17T04:21:41-07:00</updated>
    <id>http://hustcalm.me/blog/2014/04/17/build-ptam-on-fedora-20-the-easy-way-10-minutes-tutorial</id>
    <content type="html"><![CDATA[<p>It&rsquo;s been a while since the last post <a href="http://hustcalm.me/blog/2013/09/27/ptam-compilation-on-linux-howto/">PTAM Compilation on Linux-HowTo</a> about playing with PTAM. And now Isis Innovation has released the source code under GPLv3 and put it on <a href="https://github.com/Oxford-PTAM/PTAM-GPL">Github</a>.</p>

<p>Last time, we demostrate detailed instructions on how to get PTAM running on Debian derived systems(Linux Mint 15 and Ubuntu 12.04), now I want talk about building the source code on Fedora 20. It won&rsquo;t be long, since I just want to talk about the key components, thus the mandatory dependencies(<strong>TooN, libCVD, Gvars3, OpenGL, libjpeg, libpng, libtiff</strong>, etc).</p>

<!--more-->


<p>As the PTAM source code use the GNU autoconf tools, so the typical way to install is <code>./configure &amp;&amp; make &amp;&amp; sudo make install</code>, however, to make sure that certain third libs are correctly configured and can found when running <code>configure</code>, you may want to have a look at the output after <code>configure</code> and install any key dependency which is missed.</p>

<p>Whenever you are not sure, see the <strong>Official Website</strong> for sure!!!</p>

<h2>Install Dependencies</h2>

<h3>TooN</h3>

<p><a href="http://www.edwardrosten.com/cvd/toon.html">TooN</a> is a numerics library used by libCVD. Since they are just a bundle of header files, installation is trivial.</p>

<pre><code>sudo yum install liblapack-devel
sudo yum install libblas-devel

./configure &amp;&amp; make &amp;&amp; sudo make install
</code></pre>

<h3>libCVD</h3>

<p><a href="http://www.edwardrosten.com/cvd/">libCVD</a> is a very portable and high performance C++ library for computer vision, image, and video processing.</p>

<p>This is the key component for building PTAM, thus should be careful. Make sure you installed OpenGL correctly, also for the video source, if you are using a UVC webcam, check if <code>v4l2</code> is working. Or if you are using a IEEE1394 camera, get libxx1394 series libs installed which can drive your camera. For Image I/O, always have libjpeg, libpng and libtiff.</p>

<p>See the output after running <code>configure</code> and ensure all the options related are OK.</p>

<pre><code>sudo yum install freeglut-devel

./configure

make

sudo make install
</code></pre>

<h3>GVars3</h3>

<p><a href="http://www.edwardrosten.com/cvd/gvars3.html">GVars3</a> is a configuration library which integrates well with TooN. Not much to worry when buiding.</p>

<pre><code>./configure &amp;&amp; make &amp;&amp; sudo make install
</code></pre>

<h2>Build PTAM</h2>

<h3>Run ldconfig</h3>

<p>The libs built above may reside in <code>/usr/local/lib</code> when using the default directorys in their Makefiles, to make the system aware of the newly installed libs.</p>

<pre><code>sudo vi /etc/ld.so.conf
add /usr/local/lib to the file
sudo ldconfig
</code></pre>

<h3>Prepare for Makefile</h3>

<pre><code>cd the_PTAM_Directory
cp Build/Linux/* .
vi Makefile
add -lGLU -lGL -llapack to the linker commands
</code></pre>

<h3>Fix usleep declaration</h3>

<pre><code>vi Tracker.cc
add #include &lt;unistd.h&gt; to the first line
</code></pre>

<h3>Build</h3>

<pre><code>make
</code></pre>

<p>If nothing wrong, you are done!</p>

<h2>Run PTAM</h2>

<p>Simply invoke <code>CameraCalibrator</code> to calibrate your camera. Then invoke <code>PTAM</code> for real fun.</p>

<p>If you use UVC webcam using <code>v4l2</code>, you may want to install:</p>

<pre><code>sudo yum install v4l-utils
</code></pre>

<p>Use <code>v4l2-ctl</code> to play with your camera.</p>

<h2>Trouble Shooting</h2>

<p>As the orinigal <a href="http://www.robots.ox.ac.uk/~gk/PTAM/README.txt">README.txt</a> says, PTAM works well with Nvidia display card, I got <code>Segmentation Fault as soon as ... got video source</code> as I&rsquo;m using a display card shipped with an Intel motherboard.</p>

<p>However, I think the root cause is that the display card driver does not know how to handle the color space coming from the webcam, so I&rsquo;m planning to deep into the mechanism and try to find out why. <a href="http://ewokrampage.wordpress.com/troubleshooting-faq/">George Klein</a> says that a nvidia display card and driver combo works fine after all.</p>
]]></content>
  </entry>
  
</feed>
