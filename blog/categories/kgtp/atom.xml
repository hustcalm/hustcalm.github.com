<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: KGTP | Welcome to Pandora's Box]]></title>
  <link href="http://hustcalm.me/blog/categories/kgtp/atom.xml" rel="self"/>
  <link href="http://hustcalm.me/"/>
  <updated>2020-01-15T13:01:39-08:00</updated>
  <id>http://hustcalm.me/</id>
  <author>
    <name><![CDATA[Lihang Li]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[KGTP中增加对GDB命令“set trace-buffer-size”的支持 - Week 4]]></title>
    <link href="http://hustcalm.me/blog/2014/08/10/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-4/"/>
    <updated>2014-08-10T03:33:09-07:00</updated>
    <id>http://hustcalm.me/blog/2014/08/10/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-4</id>
    <content type="html"><![CDATA[<h3>CSDN开源夏令营 &ndash; 第四周工作总结</h3>

<p>本周主要是在回顾“set trace-buffer-size”完成通信的基础上，对于指定参数size的处理，比如指定-1或者unlimited的时候，在KGTP端该如何做解析，以及该如何处理此时的buffer size。同时，根据“开题报告"的进度，中期检查的任务已经完成。对Trace Buffer的实现，做了初步的调研。</p>

<h4>1. GDB和KGTP通信实现的回顾</h4>

<p>利用GDBRSP，即GDB Remote Serial Protocol，GDB远程串行通信协议。简单来说，用于GDB远程调试发包，但是也支持File I/O和Console，而KGTP正是利用了GDBRSP对于File I/O的支持，完成GDB和KGTP的通信，在接受到GDB发送的Packet后，KGTP进行解析。而通信的介质则是通过debugfs或者其他kernel space和user space进行数据交换的接口进行的。
具体实现，可以参考上一篇博文[1]。</p>

<!--more-->


<h4>2. GDB的Packet格式</h4>

<p>GDB向target发送的Packet必须遵守提前设定的约定，才能被target按照相应的规则解析处理。关于GDB的Packet格式，可以参考[2]，这里详细列出了所有的预定义的指令和它们相应的响应数据。如果想进一步了解GDBRSP，可以阅读[3]。由于KGTP对Trace Point最感兴趣，因此我们也最关注Tracepoint Packets，只要有两种，分别以Q和q开头，其中Q表示设置命令，即set，而q表示查询命令，即query，具体看[4]。关于如何开始和停止Trace Experiments，看[5]。GDB对于用户输入的commands，会转换后封装成Packet，通过GDBRSP发给target，因此需要结合着[4]和[5]才能把对某一个命令如何进行包解析搞清楚，比如用户输入”tstart“，则会发送一个”QTStart“的包。</p>

<h4>3. KGTP对GDB的Packet的处理实现</h4>

<p>有了GDB和KGTP的通信的基础设施，比如DebugFS和GDBRSP，正常的文件读写即可完成GDB和KGTP的数据交换。而为了完成相应的任务，KGTP必须对接收到的GDB的Packet进行解析，而我们又知道了GDB得Packet格式，因此只需要对接收到的数据按照格式做相应的解析即可。</p>

<p>在<code>gtp.c</code>的<code>gtp_write</code>函数，针对接收到的GDB包做了具体的解析，具体代码如下：</p>

<pre><code>static ssize_t
gtp_write(struct file *file, const char __user *buf, size_t size,
      loff_t *ppos)
{
    char        *rsppkg = NULL;
    int     i, ret;
    unsigned char   csum;
    int     is_reverse;

    if (down_interruptible(&gt;p_rw_lock))
        return -EINTR;

    if (size == 0) {
#ifdef GTP_DEBUG
        printk(GTP_DEBUG "gtp_write: try write 0 size.\n");
#endif
        goto error_out;
    }

    size = min_t(size_t, size, GTP_RW_MAX);
    if (copy_from_user(gtp_rw_buf, buf, size)) {
        size = -EFAULT;
        goto error_out;
    }

    if (gtp_rw_buf[0] == '+' || gtp_rw_buf[0] == '-'
        || gtp_rw_buf[0] == '\3' || gtp_rw_buf[0] == '\n') {
        if (gtp_rw_buf[0] == '+')
            gtp_rw_size = 0;
        size = 1;
        goto out;
    }

    if (size &lt; 4) {
        size = -EINVAL;
        goto error_out;
    }
    /* Check format and get the rsppkg.  */
    for (i = 0; i &lt; size - 2; i++) {
        if (gtp_rw_buf[i] == '$')
            rsppkg = gtp_rw_buf + i + 1;
        else if (gtp_rw_buf[i] == '#')
            break;
    }
    if (rsppkg &amp;&amp; gtp_rw_buf[i] == '#') {
        /* Format is OK.  Check crc.  */
        if (gtp_noack_mode &lt; 1)
            gtp_read_ack = 1;
        size = i + 3;
        gtp_rw_buf[i] = '\0';
    } else {
        printk(KERN_WARNING "gtp_write: format error\n");
        size = -EINVAL;
        goto error_out;
    }

    wake_up_interruptible_nr(&gt;p_rw_wq, 1);

    up(&gt;p_rw_lock);
    if (down_interruptible(&gt;p_rw_lock))
        return -EINTR;

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_write: %s\n", rsppkg);
#endif

    /* Handle rsppkg and put return to gtp_rw_buf.  */
    gtp_rw_buf[0] = '$';
    gtp_rw_bufp = gtp_rw_buf + 1;
    gtp_rw_size = 0;
    ret = 1;
    is_reverse = 0;
    switch (rsppkg[0]) {
    case '?':
        if (gtp_current_pid == 0)
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "S05");
        else
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "T05;thread:p%x.%x;",
                 gtp_current_pid, gtp_current_pid);
        gtp_rw_size += strlen(gtp_rw_bufp);
        gtp_rw_bufp += strlen(gtp_rw_bufp);
        break;
    case 'g':
        ret = gtp_gdbrsp_g();
        break;
    case 'm':
        ret = gtp_gdbrsp_m(rsppkg + 1);
        break;
    case 'Q':
#ifdef GTP_RB
        /* This check for "tfind -1" and let GDB into step replay.
           XXX: just test on X86_64.  */
        if (gtp_replay_step_id) {
            if (strcmp("QTFrame:ffffffff", rsppkg) == 0) {
                ret = 0;
                goto switch_done;
            } else
                gtp_replay_reset();
        }
#endif
        if (rsppkg[1] == 'T')
            ret = gtp_gdbrsp_QT(rsppkg + 2);
        else if (strncmp("QStartNoAckMode", rsppkg, 15) == 0) {
            ret = 0;
            gtp_noack_mode = -1;
        }
        break;
    case 'q':
        if (rsppkg[1] == 'T')
            ret = gtp_gdbrsp_qT(rsppkg + 2);
        else if (rsppkg[1] == 'C') {
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "QC%x",
                 gtp_current_pid);
            gtp_rw_size += strlen(gtp_rw_bufp);
            gtp_rw_bufp += strlen(gtp_rw_bufp);
            ret = 1;
        } else if (strncmp("qSupported", rsppkg, 10) == 0) {
#ifdef GTP_RB
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX,
                 "QStartNoAckMode+;ConditionalTracepoints+;"
                 "TracepointSource+;DisconnectedTracing+;"
                 "ReverseContinue+;ReverseStep+;"
#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,30))
                 "EnableDisableTracepoints+;"
#endif
                 "qXfer:traceframe-info:read+;");
#endif
#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX,
                 "QStartNoAckMode+;ConditionalTracepoints+;"
#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,30))
                 "EnableDisableTracepoints+;"
#endif
                 "TracepointSource+;DisconnectedTracing+;");
#endif
            gtp_rw_size += strlen(gtp_rw_bufp);
            gtp_rw_bufp += strlen(gtp_rw_bufp);
            ret = 1;
        }
#ifdef GTP_RB
        else if (strncmp("qXfer:traceframe-info:read::",
                   rsppkg, 28) == 0)
            ret = gtp_gdbrsp_qxfer_traceframe_info_read(rsppkg
                                    + 28);
#endif
        else if (strncmp("qRcmd,", rsppkg, 6) == 0)
            ret = gtp_gdbrsp_qRcmd(rsppkg + 6);
        else if (strncmp("qAttached", rsppkg, 9) == 0) {
            snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "1");
            gtp_rw_size += 1;
            gtp_rw_bufp += 1;
        }
        break;
    case 'S':
    case 'C':
        ret = -1;
        break;
    case 'b':
        rsppkg[0] = rsppkg[1];
        is_reverse = 1;
    case 's':
    case 'c':
        ret = gtp_gdbrsp_resume (rsppkg[0] == 's', is_reverse);
        break;
    case 'v':
        if (strncmp("vAttach;", rsppkg, 8) == 0) {
#ifdef GTP_RB
            if (gtp_replay_step_id)
                gtp_replay_reset();
#endif
            ret = gtp_gdbrsp_vAttach(rsppkg + 8);
        } else if (strncmp("vKill;", rsppkg, 7) == 0) {
#ifdef GTP_RB
            if (gtp_replay_step_id)
                gtp_replay_reset();
#endif
            /* XXX:  When we add more code to support trace
               user space program.  We need add more release
               code to this part.
               Release tracepoint for this tracepoint.  */
            ret = 0;
        }
        break;
    case 'D':
#ifdef GTP_RB
        if (gtp_replay_step_id)
            gtp_replay_reset();
#endif
        gtp_gdbrsp_D(rsppkg + 1);
        ret = 0;
        break;
    case 'H':
        ret = gtp_gdbrsp_H(rsppkg + 1);
        break;
    case 'Z':
    case 'z':
        if (rsppkg[1] == '0')
            ret = gtp_gdbrsp_breakpoint(rsppkg + 3,
                            (rsppkg[0] == 'Z'));
        break;
    }
switch_done:
    if (ret == 0) {
        snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "OK");
        gtp_rw_bufp += 2;
        gtp_rw_size += 2;
    } else if (ret &lt; 0) {
        snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "E%02x", -ret);
        gtp_rw_bufp += 3;
        gtp_rw_size += 3;
    }

    gtp_rw_bufp[0] = '#';
    csum = 0;
    for (i = 1; i &lt; gtp_rw_size + 1; i++)
        csum += gtp_rw_buf[i];
    gtp_rw_bufp[1] = INT2CHAR(csum &gt;&gt; 4);
    gtp_rw_bufp[2] = INT2CHAR(csum &amp; 0x0f);
    gtp_rw_bufp = gtp_rw_buf;
    gtp_rw_size += 4;

out:
    wake_up_interruptible_nr(&gt;p_rw_wq, 1);
error_out:
    up(&gt;p_rw_lock);
    return size;
}
</code></pre>

<p>我们可以看到根据接收到的Packet，分别调用了不同的handler来做处理，这里我们重点关注Tracepoint Packets，关于以QT开头的包，处理代码如下：</p>

<pre><code>static int
gtp_gdbrsp_QT(char *pkg)
{
    int ret = 1;

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_QT: %s\n", pkg);
#endif

    if (strcmp("init", pkg) == 0)
        ret = gtp_gdbrsp_qtinit();
    else if (strcmp("Stop", pkg) == 0)
        ret = gtp_gdbrsp_qtstop();
    else if (strcmp("Start", pkg) == 0)
        ret = gtp_gdbrsp_qtstart();
    else if (strncmp("DP:", pkg, 3) == 0)
        ret = gtp_gdbrsp_qtdp(pkg + 3);
    else if (strncmp("DPsrc:", pkg, 6) == 0)
        ret = gtp_gdbrsp_qtdpsrc(pkg + 6);
    else if (strncmp("Disconnected:", pkg, 13) == 0)
        ret = gtp_gdbrsp_qtdisconnected(pkg + 13);
    else if (strncmp("Buffer:", pkg, 7) == 0)
        ret = gtp_gdbrsp_qtbuffer(pkg + 7);
    else if (strncmp("Frame:", pkg, 6) == 0)
        ret = gtp_gdbrsp_qtframe(pkg + 6);
    else if (strncmp("ro:", pkg, 3) == 0)
        ret = gtp_gdbrsp_qtro(pkg + 3);
    else if (strncmp("DV:", pkg, 3) == 0)
        ret = gtp_gdbrsp_qtdv(pkg + 3);
#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,30))
    else if (strncmp("Enable:", pkg, 7) == 0)
        ret = gtp_gdbrsp_qtenable_qtdisable(pkg + 7, 1);
    else if (strncmp("Disable:", pkg, 8) == 0)
        ret = gtp_gdbrsp_qtenable_qtdisable(pkg + 8, 0);
#endif

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_QT: return %d\n", ret);
#endif

    return ret;
}
</code></pre>

<p>而以qT打头的包，处理的接口如下：</p>

<pre><code>static int
gtp_gdbrsp_qT(char *pkg)
{
    int ret = 1;

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_qT: %s\n", pkg);
#endif

    if (strcmp("Status", pkg) == 0)
        ret = gtp_gdbrsp_qtstatus();
    else if (strcmp("fP", pkg) == 0)
        ret = gtp_gdbrsp_qtfp();
    else if (strcmp("sP", pkg) == 0)
        ret = gtp_gdbrsp_qtsp();
    else if (strcmp("fV", pkg) == 0)
        ret = gtp_gdbrsp_qtfsv(1);
    else if (strcmp("sV", pkg) == 0)
        ret = gtp_gdbrsp_qtfsv(0);
    else if (strncmp("V:", pkg, 2) == 0)
        ret = gtp_gdbrsp_qtv(pkg + 2);

    return ret;
</code></pre>

<p>从以上接口可以看到，是一个dispatch的过程，KGTP首先判断接收到的GDB包属于哪一类包，之后分发，而对于一个类型的包，又细分很多子包，最终分发给具体的接口实现，拿上面为例，有如下一个流程：
<strong>gtp_write &ndash;> gtp_gdbrsp_QT &ndash;> gtp_gdbrsp_qtbuffer</strong>。</p>

<p>通过以上分析，我们已经在Packet层面对GDB和KGTP的通信有了深入的理解。</p>

<h4>4. KGTP中set-buffer-size的处理逻辑</h4>

<p>有了以上分析，在用户输入了以下指令：</p>

<pre><code>set remote trace buffer-size on
set trace-buffer-size xxx
</code></pre>

<p>之后会发生什么呢？</p>

<p>让我们分别测试一下。</p>

<p>（1）set trace-buffer-size 100</p>

<pre><code>Aug 03 11:00:08 localhost.localdomain kernel: gtp_write: QTBuffer:size:64
Aug 03 11:00:08 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:64
Aug 03 11:00:08 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 11:00:08 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:setting buffer size to 100
Aug 03 11:00:08 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 11:00:08 localhost.localdomain kernel: gtp_read
</code></pre>

<p>（2）set trace-buffer-size 1000000</p>

<pre><code>Aug 03 11:00:33 localhost.localdomain kernel: gtp_write: QTBuffer:size:f4240
Aug 03 11:00:33 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:f4240
Aug 03 11:00:33 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 11:00:33 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:setting buffer size to 1000000
Aug 03 11:00:33 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 11:00:33 localhost.localdomain kernel: gtp_read
</code></pre>

<p>（3）set trace-buffer-size -1</p>

<pre><code>Aug 03 11:00:18 localhost.localdomain kernel: gtp_write: QTBuffer:size:-1
Aug 03 11:00:18 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:-1
Aug 03 11:00:18 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 11:00:18 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:setting buffer size to 0
Aug 03 11:00:18 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 11:00:18 localhost.localdomain kernel: gtp_read
</code></pre>

<p>（4）set trace-buffer-size unlimited</p>

<pre><code>Aug 03 11:00:44 localhost.localdomain kernel: gtp_write: QTBuffer:size:-1
Aug 03 11:00:44 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:-1
Aug 03 11:00:44 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 11:00:44 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:setting buffer size to 0
Aug 03 11:00:44 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 11:00:44 localhost.localdomain kernel: gtp_read
</code></pre>

<p>可以看到，<code>This packet directs the target to make the trace buffer be of size size if possible. A value of -1 tells the target to use whatever size it prefers</code>.</p>

<p>也就是说，-1和unlimited等价，GDB告诉target可以使用自己认为合适的size，而给一个合理范围的正整数n，则会要求target使用的buffer size为n，单位是byte。</p>

<p>因此，当我们接到GDB发来的size为-1的包时，可以直接忽略掉，而收到normal size的包时，需要跟当前使用的buffer size作对比，然后做相应处理。</p>

<h4>5. KGTP中set-buffer-size的具体实现</h4>

<p>目前KGTP的set-buffer-size分支，已经实现了对size处理的逻辑，参考[6]，具体代码如下：</p>

<pre><code>static int
gtp_gdbrsp_qtbuffer(char *pkg)
{
#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_qtbuffer\n");
#endif

    // Handle QTBuffer:circular:value
    if (strncmp("circular:", pkg, 9) == 0) {
        ULONGEST setting;

        pkg += 9;
        if (pkg[0] == '\0')
            return -EINVAL;
        hex2ulongest(pkg, &amp;setting);

#ifdef GTP_FTRACE_RING_BUFFER
#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,38)) \
    || defined(GTP_SELF_RING_BUFFER)
        gtp_circular = (int)setting;
        if (gtp_frame)
            ring_buffer_change_overwrite(gtp_frame, (int)setting);
#else
        if (gtp_circular != (int)setting)
            gtp_circular_is_changed = 1;
#endif
#endif
        gtp_circular = (int)setting;

        return 0;
    }
    // Handle QTBuffer:size:size 
    else if (strncmp("size:", pkg, 5) == 0) {

        ULONGEST size;
        int unlimited_or_not;

        pkg += 5;

        if (pkg[0] == '\0')
            return -EINVAL;

        // The size may equal to -1, so compare the pkg with "-1"
        if((strncmp("-1", pkg, 2) == 0) &amp;&amp; (*(pkg + 2) == '\0')) {
            unlimited_or_not = 1;
        }

        if(unlimited_or_not == 1) {
            // The user wants KGTP to choose the right size
            // So we just ignore the request

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_qtbuffer:keep buffer size as the user tells KGTP to use unlimited size");
#endif

            return 0;
        }

        // User wants to change the buffer size
        hex2ulongest(pkg, &amp;size);

#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_qtbuffer:setting buffer size to %ld\n", size);
#endif

        // Handle the new ringbuffer size blow
        // gtp_set_trace_buffer_size(size);

        return 0;
    }

    return 1;
}
</code></pre>

<p>让我们测试一下：</p>

<p>（1）set trace-buffer-size -1</p>

<pre><code>Aug 03 12:37:28 localhost.localdomain kernel: gtp_write: QTBuffer:size:-1
Aug 03 12:37:28 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:-1
Aug 03 12:37:28 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 12:37:28 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:keep buffer size as the user tells KGTP to use unlimited size
Aug 03 12:37:28 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 12:37:28 localhost.localdomain kernel: gtp_read
</code></pre>

<p>（2）set trace-buffer-size unlimited</p>

<pre><code>Aug 03 12:37:57 localhost.localdomain kernel: gtp_write: QTBuffer:size:-1
Aug 03 12:37:57 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:-1
Aug 03 12:37:57 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Aug 03 12:37:57 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer:keep buffer size as the user tells KGTP to use unlimited size
Aug 03 12:37:57 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Aug 03 12:37:57 localhost.localdomain kernel: gtp_read
</code></pre>

<p>Bingo！目前已经正确地实现了对size的解析处理，接下来的工作是继续调研KGTP trace buffer的实现，并根据size大小做出调整。</p>

<h4>6. 参考链接</h4>

<ul>
<li>[1] <a href="http://blog.csdn.net/calmdownba/article/details/38174759">http://blog.csdn.net/calmdownba/article/details/38174759</a></li>
<li>[2] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Packets.html#Packets">https://sourceware.org/gdb/current/onlinedocs/gdb/Packets.html#Packets</a></li>
<li>[3] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Remote-Protocol.html#Remote-Protocol">https://sourceware.org/gdb/current/onlinedocs/gdb/Remote-Protocol.html#Remote-Protocol</a></li>
<li>[4] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html</a></li>
<li>[5] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html</a></li>
<li>[6] <a href="https://code.csdn.net/Calmdownba/kgtp/tree/set-buffer-size">https://code.csdn.net/Calmdownba/kgtp/tree/set-buffer-size</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KGTP中增加对GDB命令“set trace-buffer-size”的支持 - Week 3]]></title>
    <link href="http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-3/"/>
    <updated>2014-07-27T04:34:52-07:00</updated>
    <id>http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-3</id>
    <content type="html"><![CDATA[<h3>CSDN开源夏令营 &ndash; 第三周工作总结</h3>

<p>这一周主要实现了“set trace-buffer-size”实现的数据通信部分，即完成了GDB和KGTP的数据交互部分，下面简单分析一下实现。在说代码实现之前，还是简单地回顾一下，如何摸清KGTP的脉络。</p>

<h4>1. 如何跟踪KGTP</h4>

<p>我的平台是Fedora，步骤如下：</p>

<pre><code>make D=1
sudo insmod gtp.ko
sudo gdb /usr/lib/debug/lib/modules/3.14.8-200.fc20.x86_64/vmlinux -ex 'target remote /sys/kernel/debug/gtp'
</code></pre>

<!--more-->


<p>此时，进入了gdb的console，可以通过gdb的commands和KGTP通信了。观察KGTP的一个重要的手段则是看printk的信息，由于编译时使用了“make D=1”，因此对应KGTP的代码，比如：</p>

<pre><code> #ifdef GTP_DEBUG                                                                                            
     printk(GTP_DEBUG "gtp_gdbrsp_qtbuffer\n");                                                              
 #endif    
</code></pre>

<p>查看这些的方式则是使用“journalctl -k”，方便起见可以只查看末尾的部分信息，比如“journalctl -k -n 100”，在我的本地输出的部分信息如下：</p>

<pre><code>Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: qAttached
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: qOffsets
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: g
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: m0,1
Jul 27 06:07:29 localhost.localdomain kernel: gtp_gdbrsp_m: addr = 0x0 len = 1
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: m0,1
Jul 27 06:07:29 localhost.localdomain kernel: gtp_gdbrsp_m: addr = 0x0 len = 1
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: qSymbol::
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: qTStatus
Jul 27 06:07:29 localhost.localdomain kernel: gtp_gdbrsp_qT: Status
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
Jul 27 06:07:29 localhost.localdomain kernel: gtp_write: qTfP
Jul 27 06:07:29 localhost.localdomain kernel: gtp_gdbrsp_qT: fP
Jul 27 06:07:29 localhost.localdomain kernel: gtp_read
</code></pre>

<p>根据以上信息，可以顺藤摸瓜找到相应被调用的函数，从而屡清楚程序的执行逻辑，这对于理解KGTP的工作原理是非常有帮助的。关于journalctl[1]的使用，请自行“man journalctl”。在非systemd[2]的系统下，可能还需要通过“less /var/log/”这样的方式查看内核的输出，根据你使用的Linux随机应变即可。</p>

<h4>2. GDB和KGTP的通信实现</h4>

<p>利用GDBRSP[3]，即GDB Remote Serial Protocol，GDB远程串行通信协议。关于Remote Serial Protocol，可以参考[4]。简单来说，用于GDB远程调试发包，但是也支持File I/O和Console[5]，而KGTP正是利用了GDBRSP对于File I/O的支持，完成GDB和KGTP的通信，在接受到GDB发送的Packet后，KGTP进行解析。而通信的介质则是通过debugfs或者其他kernel space和user space进行数据交换的接口进行的。</p>

<p>具体的实现，参考gtp.c的函数 <code>gtp_init</code>，部分代码如下：</p>

<pre><code> gtp_dir = debugfs_create_file("gtp", S_IRUSR | S_IWUSR, NULL,
                   NULL, &amp;gtp_operations);
 if (gtp_dir == NULL || gtp_dir == ERR_PTR(-ENODEV)) {
     gtp_dir = NULL;
     goto out;
 }
 gtpframe_dir = debugfs_create_file("gtpframe", S_IRUSR, NULL,
                    NULL, &amp;gtpframe_operations);
 if (gtpframe_dir == NULL || gtpframe_dir == ERR_PTR(-ENODEV)) {
     gtpframe_dir = NULL;
     goto out;
 }
</code></pre>

<p>可以看到，使用DebugFS，建立了相应的文件节点，比如gtp，gtpframe，并且注册了相应的file operations，比如<code>gtp_oprations</code>，<code>gtpframe_operations</code>。</p>

<p>拿前者为例，声明的代码如下：</p>

<pre><code>static const struct file_operations gtp_operations = {
     .owner      = THIS_MODULE,
     .open       = gtp_open,
     .release    = gtp_release,
 #if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,35))
     .ioctl      = gtp_ioctl,
 #else
     .unlocked_ioctl = gtp_ioctl,
     .compat_ioctl   = gtp_ioctl,
 #endif
     .read       = gtp_read,
     .write      = gtp_write,
     .poll       = gtp_poll,
 };
</code></pre>

<p>而这其中最核心的则是<code>gtp_read</code>和<code>gtp_write</code>，其中<code>gtp_read</code>，用于GDB从KGTP读取数据（<strong>copy_to_user</strong>），gtp_write，则是KGTP从GDB接收数据（<strong>copy_from_user</strong>）。具体的代码，这里就不贴了，大家可以自行分析。</p>

<p>GDB和KGTP通过GDBRSP关联，通过执行<code>target remote /sys/kernel/debug/gtp</code>实现。</p>

<h4>3. 添加“set-trace-buffer-size”的通信支持</h4>

<p>有了以上的理论分析和准备，我们就可以着手实现“set trace-buffer-size”命令的解析了。首先，我们需要知道这个命令对应的GDBRSP的Query Packet以及KGTP利用哪个函数对其进行解析。通过[6]和[7]，我们得知如下信息：</p>

<pre><code>set circular-trace-buffer on
set circular-trace-buffer off
Choose whether a tracing run should use a linear or circular buffer for trace data. A linear buffer will not lose any trace data, but may fill up prematurely, while a circular buffer will discard old trace data, but it will have always room for the latest tracepoint hits.

show circular-trace-buffer
Show the current choice for the trace buffer. Note that this may not match the agent’s current buffer handling, nor is it guaranteed to match the setting that might have been in effect during a past run, for instance if you are looking at frames from a trace file.

set trace-buffer-size n
set trace-buffer-size unlimited
Request that the target use a trace buffer of n bytes. Not all targets will honor the request; they may have a compiled-in size for the trace buffer, or some other limitation. Set to a value of unlimited or -1 to let the target use whatever size it likes. This is also the default.

show trace-buffer-size
Show the current requested size for the trace buffer. Note that this will only match the actual size if the target supports size-setting, and was able to handle the requested size. For instance, if the target can only change buffer size between runs, this variable will not reflect the change until the next run starts. Use tstatus to get a report of the actual buffer size.


‘QTBuffer:circular:value’
This packet directs the target to use a circular trace buffer if value is 1, or a linear buffer if the value is 0.

‘QTBuffer:size:size’
This packet directs the target to make the trace buffer be of size size if possible. A value of -1 tells the target to use whatever size it prefers.
</code></pre>

<p>嗯，有线索了，GDB执行相应地指令，则会通过GDBRSP向KGTP发送相应的Query Packet，注意到“circular-trace-buffer”和“trace-buffer-size”的Packet的格式相同。关于GDB的General Query Packet，参考[8]。<strong>Packets starting with ‘q’ are general query packets; packets starting with ‘Q’ are general set packets. General query and set packets are a semi-unified form for retrieving and sending information to and from the stub.</strong></p>

<p>因此，参考“circular-trace-buffer”的实现是一个很好的突破口，所幸的是，KGTP已经实现了对其的支持。</p>

<h4>4. 添加“set trace-buffer-size”的具体实现</h4>

<p>根据以上分析，我们很快找到了两个关键函数，“gtp_gdbrsp_QT  ”和“gtp_gdbrsp_qtbuffer”。OK，添加对“set trace-buffer-size”的解析，代码如下：</p>

<pre><code>static int
gtp_gdbrsp_qtbuffer(char *pkg)
{
#ifdef GTP_DEBUG
    printk(GTP_DEBUG "gtp_gdbrsp_qtbuffer\n");
#endif

    // Handle QTBuffer:circular:value
    if (strncmp("circular:", pkg, 9) == 0) {
        ULONGEST setting;

        pkg += 9;
        if (pkg[0] == '\0')
            return -EINVAL;
        hex2ulongest(pkg, &amp;setting);

#ifdef GTP_FTRACE_RING_BUFFER
#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,38)) \
    || defined(GTP_SELF_RING_BUFFER)
        gtp_circular = (int)setting;
        if (gtp_frame)
            ring_buffer_change_overwrite(gtp_frame, (int)setting);
#else
        if (gtp_circular != (int)setting)
            gtp_circular_is_changed = 1;
#endif
#endif
        gtp_circular = (int)setting;

        return 0;
    }
    // Handle QTBuffer:size:size 
    else if (strncmp("size:", pkg, 5) == 0) {

        ULONGEST size;

        pkg += 5;

        if (pkg[0] == '\0')
            return -EINVAL;
        hex2ulongest(pkg, &amp;size);

        // Handle the new ringbuffer size blow

        return 0;
    }

    return 1;
}
</code></pre>

<p>重新编译，安装模块，然后在GDB中输入“set trace-buffer-size 100”，注意这里的100是十进制的，看下“journalctl -k”的输出，啥也没有。怎么回事，上面分析的不是挺美好的吗？经过几次尝试未果，把问题定位在了GDB对于Remote Packet的处理，不会是没有enable吧？</p>

<p>查看文档[9]，果然，应该使用<code>set remote set-buffer-size on</code>先使能，否则应该是直接被gdbrsp丢掉了。OK，使用<code>set trace-buffer-size 100</code>，输出：</p>

<pre><code>Jul 27 07:18:45 localhost.localdomain kernel: gtp_write: QTBuffer:size:64
Jul 27 07:18:45 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:64
Jul 27 07:18:45 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Jul 27 07:18:45 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Jul 27 07:18:45 localhost.localdomain kernel: gtp_read
</code></pre>

<p>而使用<code>set trace-buffer-size unlimited</code>，输出：</p>

<pre><code>Jul 27 07:19:53 localhost.localdomain kernel: gtp_write: QTBuffer:size:-1
Jul 27 07:19:53 localhost.localdomain kernel: gtp_gdbrsp_QT: Buffer:size:-1
Jul 27 07:19:53 localhost.localdomain kernel: gtp_gdbrsp_qtbuffer
Jul 27 07:19:53 localhost.localdomain kernel: gtp_gdbrsp_QT: return 0
Jul 27 07:19:53 localhost.localdomain kernel: gtp_read
</code></pre>

<p>OK，至此对于“set trace-buffer-size”的通信支持就完成了，接下来需要根据用户设置的size对trace buffer做出调整，接下来的文章会说到如何实现。</p>

<h4>5. 参考链接</h4>

<ul>
<li> [1] <a href="http://www.freedesktop.org/software/systemd/man/journalctl.html">http://www.freedesktop.org/software/systemd/man/journalctl.html</a></li>
<li> [2] <a href="https://wiki.archlinux.org/index.php/systemd">https://wiki.archlinux.org/index.php/systemd</a></li>
<li> [3] <a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html</a></li>
<li> [4] <a href="http://blog.csdn.net/hmsiwtv/article/details/8759129">http://blog.csdn.net/hmsiwtv/article/details/8759129</a></li>
<li> [5] <a href="https://sourceware.org/gdb/onlinedocs/gdb/File_002dI_002fO-Remote-Protocol-Extension.html#File_002dI_002fO-Remote-Protocol-Extension">https://sourceware.org/gdb/onlinedocs/gdb/File_002dI_002fO-Remote-Protocol-Extension.html#File_002dI_002fO-Remote-Protocol-Extension</a></li>
<li> [6] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html</a></li>
<li> [7] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html</a></li>
<li> [8] <a href="https://www.sourceware.org/gdb/onlinedocs/gdb/General-Query-Packets.html#General-Query-Packets">https://www.sourceware.org/gdb/onlinedocs/gdb/General-Query-Packets.html#General-Query-Packets</a></li>
<li> [9] <a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Configuration.html">https://sourceware.org/gdb/onlinedocs/gdb/Remote-Configuration.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KGTP中增加对GDB命令“set trace-buffer-size”的支持 - Week 2]]></title>
    <link href="http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-2/"/>
    <updated>2014-07-27T04:34:48-07:00</updated>
    <id>http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-2</id>
    <content type="html"><![CDATA[<h3>CSDN开源夏令营 &ndash; 第二周工作总结</h3>

<p>这一周在上一周对整体框架的认识和理解之上，开始全面地阅读KGTP的源代码，理解了梗概，很多细节需要再仔细研读，主要参考是其代码仓库：[1]。</p>

<h4>1. KGTP的核心代码文件</h4>

<p>毫无疑问，KGTP最精髓的代码都在gtp.c文件中，约13500行代码，这其中包括了与GDB的通信，具体Query Packets的处理，Trace Points的注册和删除，事件的触发，硬件断点的设置和处理，等几乎所有的KGTP核心事务。在短短1万多行代码中，体现了几乎所有Linux Kernel开发过程中会用到的features，SMP的支持，Linux的list实现，锁和同步，工作队列，tasklet，硬件和软件中断，等等。</p>

<!--more-->


<p>其它辅助文件则有：</p>

<ul>
<li> <code>gtp_rb.c</code>      KGTP自己实现的一套Ring Buffer（默认使用）</li>
<li> <code>perf_event.c</code>  Perf的核心实现，里面也实现Ring Buffer</li>
<li> <code>ring_buffer.c</code> Linux内核为Trace的infrastructure提供的统一的Ring Buffer实现（比如Ftrace）</li>
</ul>


<h4>2. KGTP核心功能实现的源码分析</h4>

<p>按照数据通信流程，<strong>GDB ——>   GDBRSP ——> SYSFS ——> KGTP ——> Kernel</strong>，简单分析如下：</p>

<p><code>GDBRSP</code>是Remote Serial Protocol，用于GDB远程调试发包，但是也支持File I/O和Console，而KGTP正是利用了GDBRSP对于File I/O的支持，完成GDB和KGTP的通信，在接受到GDB发送的Packet后，KGTP进行解析。而通信的介质则是通过debugfs或者其他kernel space和user space进行数据交换的接口进行（参考[2]）。</p>

<p>KGTP接收到了GDB的指令后，基于Kprobes和Uprobes进行内核和用户应用程序的trace，step和watch可以基于hardware-breakpoints实现。</p>

<p>KGTP自己维护了一个ring buffer的，用于Trace Frame的存储，查询及dump。</p>

<h5>（1）KGTP和GDB的通信</h5>

<p>核心函数：</p>

<ul>
<li> <code>gtp_init</code>    建立对应的ProcFS或者DebugFS文件结点</li>
</ul>


<p>以下函数利用GDBRSP完成GDB和KGTP基于packet的通信：</p>

<ul>
<li> <code>gtp_open</code></li>
<li> <code>gtp_release</code></li>
<li> <code>gtp_ioctl</code></li>
<li> <code>gtp_write</code></li>
<li> <code>gtp_read</code></li>
<li> <code>gtp_poll</code></li>
</ul>


<h5>（2）KGTP对GDB数据包的处理</h5>

<p><code>gtp_gdbrsp_*</code> 系列函数完成了对GDB数据包的解析和处理。</p>

<p>比如：</p>

<ul>
<li> <code>gtp_gdbrsp_QT</code>        处理QT的packet</li>
<li> <code>gtp_gdbrsp_qtstart</code>   Start Trace Experiments，注册kprobe，uprobe以及watchpoints，hardware breakpoints等，并分配存储空间</li>
<li> <code>gtp_qdbrsp_qtstop</code>    Stop Trace Experiments，flush work queue，tasklet_kill，以及unregister在qtstart注册的所有probe points和一些回调函数</li>
</ul>


<p>参考的话，就是GDB的官方手册了，比如：</p>

<p>GDB的<a href="https://www.sourceware.org/gdb/onlinedocs/gdb/General-Query-Packets.html">Query Packet</a>.
Packets starting with ‘q’ are general query packets; packets starting with ‘Q’ are general set packets. General query and set packets are a semi-unified form for retrieving and sending information to and from the stub.</p>

<h5>（3）Tracepoints和Breakpoints的注册和删除</h5>

<ul>
<li> <code>gtp_uprobe_register</code></li>
<li> <code>gtp_register_hwb</code></li>
<li> <code>gtp_unregister_hwb</code></li>
</ul>


<h5>（4）TSV的处理</h5>

<p><code>gtp_var_*</code></p>

<p>可以重点看一下<code>gtp_var_special_add_all</code>。</p>

<h5>（5）Ring Buffer的处理</h5>

<p>这里后续再详细分析，Ring Buffer的实现也是KGTP的核心之一。</p>

<h4>3. 阅读源码小技巧&amp;问题总结</h4>

<p>参考<code>LXR</code>[3]，直接使用<code>Identifier Search</code>[4]，遇到不明白的宏定义，函数定义，都可以直接到Linux源码中一探究竟。</p>

<p>以下是我阅读代码过程遇到的一些问题总结：</p>

<p>（1）EXPORT_SYMBOL</p>

<p><a href="http://stackoverflow.com/questions/9836467/whats-meaning-of-export-symbol-in-linux-kernel-code">http://stackoverflow.com/questions/9836467/whats-meaning-of-export-symbol-in-linux-kernel-code</a></p>

<p><a href="http://www.linux.com/learn/linux-training/31161-the-kernel-newbie-corner-kernel-symbols-whats-available-to-your-module-what-isnt">http://www.linux.com/learn/linux-training/31161-the-kernel-newbie-corner-kernel-symbols-whats-available-to-your-module-what-isnt</a></p>

<p>（2）container_of</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/kernel.h#L833">http://lxr.free-electrons.com/source/include/linux/kernel.h#L833</a></p>

<pre><code>/**
827  * container_of - cast a member of a structure out to the containing structure
828  * @ptr:        the pointer to the member.
829  * @type:       the type of the container struct this is embedded in.
830  * @member:     the name of the member within the struct.
831  *
832  */
833 #definecontainer_of(ptr,type, member) ({                      \
834         const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \
835         (type *)( (char *)__mptr - offsetof(type,member) );})
</code></pre>

<p>（3）kzalloc</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/slab.h#L649">http://lxr.free-electrons.com/source/include/linux/slab.h#L649</a></p>

<p>（4）kmalloc</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/slab.h#L452">http://lxr.free-electrons.com/source/include/linux/slab.h#L452</a></p>

<p>（5）list</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/list.h">http://lxr.free-electrons.com/source/include/linux/list.h</a></p>

<p>（6）INIT_WORK</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/workqueue.h">http://lxr.free-electrons.com/source/include/linux/workqueue.h</a></p>

<p>（7）vfree</p>

<p><a href="http://lxr.free-electrons.com/source/mm/vmalloc.c#L1490">http://lxr.free-electrons.com/source/mm/vmalloc.c#L1490</a></p>

<p>（8）preempt_disable</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/preempt.h#L38">http://lxr.free-electrons.com/source/include/linux/preempt.h#L38</a></p>

<p>（9）barrier</p>

<p><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">https://www.kernel.org/doc/Documentation/memory-barriers.txt</a></p>

<p>（10）local_irq_save</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/irqflags.h#L93">http://lxr.free-electrons.com/source/include/linux/irqflags.h#L93</a></p>

<p>（11）notifier_block</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/notifier.h#L53">http://lxr.free-electrons.com/source/include/linux/notifier.h#L53</a></p>

<p>（12）flush_workqueue</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/workqueue.c#L2641">http://lxr.free-electrons.com/source/kernel/workqueue.c#L2641</a></p>

<p>（13）tasklet_kill</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/softirq.c#L566">http://lxr.free-electrons.com/source/kernel/softirq.c#L566</a></p>

<p>（14）unregister_wide_hw_breakpoint</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/events/hw_breakpoint.c#L536">http://lxr.free-electrons.com/source/kernel/events/hw_breakpoint.c#L536</a></p>

<p>（15）unregister_kprobe</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/kprobes.c#L1668">http://lxr.free-electrons.com/source/kernel/kprobes.c#L1668</a></p>

<p>（16）wake_up_interruptible_nr</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/sched/wait.c#L88">http://lxr.free-electrons.com/source/kernel/sched/wait.c#L88</a></p>

<p>（17）queue_work</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/sched/wait.c#L88">http://lxr.free-electrons.com/source/kernel/sched/wait.c#L88</a></p>

<p>（18）rcu_read_lock</p>

<p><a href="http://lxr.free-electrons.com/source/include/linux/rcupdate.h#L798">http://lxr.free-electrons.com/source/include/linux/rcupdate.h#L798</a></p>

<p>（19）tasklet_init</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/softirq.c#L555">http://lxr.free-electrons.com/source/kernel/softirq.c#L555</a></p>

<p>（20）IPI</p>

<p><a href="http://en.wikipedia.org/wiki/Inter-processor_interrupt">http://en.wikipedia.org/wiki/Inter-processor_interrupt</a></p>

<p>（21）register_die_notifier</p>

<p><a href="http://lxr.free-electrons.com/source/kernel/notifier.c#L544">http://lxr.free-electrons.com/source/kernel/notifier.c#L544</a></p>

<p>（22）EBUSY</p>

<p><a href="http://lxr.free-electrons.com/source/include/uapi/asm-generic/errno-base.h#L19">http://lxr.free-electrons.com/source/include/uapi/asm-generic/errno-base.h#L19</a></p>

<h4>4. KGTP的调试&amp;源码注释</h4>

<p>编译KGTP的时候添加D=1，便以debug的方式编译，在Fedora下可以通过journalctl -k查看其输出，其中-k是指过滤Kernel信息。其它系统下可能是在/var/log之类的文件查看，总之KGTP通过内核接口printfk输出，视具体的系统不同，查看内核信息的方式也会有变化。</p>

<p>关于有注释的代码，请看[5]。</p>

<h4>5. 参考链接</h4>

<ul>
<li> [1] <a href="https://github.com/teawater/kgtp">https://github.com/teawater/kgtp</a></li>
<li> [2] <a href="http://people.ee.ethz.ch/~arkeller/linux/multi/kernel_user_space_howto.html#toc1">http://people.ee.ethz.ch/~arkeller/linux/multi/kernel_user_space_howto.html#toc1</a></li>
<li> [3] <a href="http://lxr.free-electrons.com">http://lxr.free-electrons.com</a></li>
<li> [4] <a href="http://lxr.free-electrons.com/ident">http://lxr.free-electrons.com/ident</a></li>
<li> [5] <a href="https://code.csdn.net/Calmdownba/kgtp/tree/comments-from-scratch">https://code.csdn.net/Calmdownba/kgtp/tree/comments-from-scratch</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KGTP中增加对GDB命令“set trace-buffer-size”的支持 - Week 1]]></title>
    <link href="http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-1/"/>
    <updated>2014-07-27T04:34:45-07:00</updated>
    <id>http://hustcalm.me/blog/2014/07/27/kgtpzhong-zeng-jia-dui-gdbming-ling-set-trace-buffer-size-de-zhi-chi-week-1</id>
    <content type="html"><![CDATA[<h3>CSDN开源夏令营 &ndash; 第一周工作总结</h3>

<p>这一周主要对KGTP的实现进行了简单的熟悉和分析，主要参考的资料在：[1]。</p>

<h4>1.什么是KGTP</h4>

<p>T大把KGTP称为Linux内核中的GDB快刀，其全称是Linux kernel GDB tracepoint module，是一个灵活轻量级实时的Linux调试器和跟踪器。</p>

<p>Linux的tracer infrastructure五花八门，包括Ftrace，Utrace等，建议大家参考一下这篇paper，【Ptrace, Utrace, Uprobes: Lightweight, Dynamic Tracing of User Apps】，下载链接在：[2]。Tracer在收集信息的时候不停止Linux内核，但是不能被GDB控制。</p>

<!--more-->


<p>而在调试Linux内核的时候，我们也有很多选择，比如KDB，KGDB等，Debugger将停止Linux内核，但是可以被GDB控制。</p>

<p>那么KGTP做了什么事情呢？Yes，作为Tracer和Debugger的一个桥梁，从而做到不停止Linux内核，且可以被本地或者远程的GDB控制。</p>

<p>目前，KGTP支持X86-32，X86-64，MIPS和ARM，支持Linux内核2.6.18到upstream，直接Android（因为Android底层仍然是Linux Kernel）。</p>

<h4>2. KGTP的实现</h4>

<p>KGTP的大部分trace功能基于Kprobe，而用户态应用程序的trace功能则依赖Uprobe，对于使用Kprobe的情况，使用Kprobes-optimization还可提高Kprobe的速度。</p>

<p>作为Debugger和Tracer之间的桥梁，KGTP通过GDB的RSP协议与GDB通信，完成数据的交换和用户命令的解析，具体的信息可以看GDB的文档，比如：<a href="https://www.sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">GDB Remote-Protocol</a>。KGTP内核态和用户态的数据交换，通过DebugFS或者ProcFS暴露给用户态的GDB。在接收到相关的GDB命令数据包后，完成相关的解析工作，设置对应的Tracepoint，在用户开始trace后（tstart），开始在Ring Buffer采集数据，结束后（tstop）可以供用户查看（tfind）。</p>

<p>KGTP作为一个内核module存在，只需要编译KGTP后insmod，而不需要重新编译内核，因此非常灵活，当不需要KGTP的时候，直接rmmod即可。</p>

<p>KGTP的数据分析主要使用GDB，因此代码中不需要很多数据分析的部分，核心源代码文件gtp.c，仅有13000行左右。</p>

<p>总结起来，KGTP是一个灵活且轻量级的实现，可以实时地对Linux进行跟踪和调试，这对于线上服务器的问题处理是非常有用的。</p>

<h4>3. KGTP的hack需要具备哪些知识</h4>

<p>C语言功底+一定的Linux内核开发基础，具体的点总结如下：</p>

<ul>
<li> （1）Linux内核的同步机制（锁，信号量等）</li>
<li> （2）字符驱动程序的实现原理，主要是GDB和KGTP的通信需要用到</li>
<li> （3）Linux内核module的编写，因此KGTP是以一个module的形式存在的</li>
<li> （4）Linux内核的tasklet和workqueue，KGTP的后台进程是一个守护进程gtpd</li>
<li> （5）Ring buffer的实现，Linux内核trace的RB的实现以及KGTP自身RB的实现</li>
<li> （6）Linux tracer的实现原理，因为KGTP是基于Kprobe和Uprobe实现的</li>
<li> （7）GDB的基本原理，尤其是GDBRSP</li>
</ul>


<h4>4. 如何增加对GDB命令“set trace-buffer-size”的支持</h4>

<ul>
<li> （1）实现命令包的解析，参考[3][4]</li>
<li> （2）实现Ring Buffer数据的拷贝和其他处理（主要针对新分配缓冲区小于原有缓冲区的情况）</li>
</ul>


<h4>5. 如何部署KGTP</h4>

<p>强烈建议采用“一键安装”的方式，KGTP提供了部署脚本[kgtp.py]，十分方便。</p>

<p>Kernel需要相应地debug info，因此如果是自己编译内核，则需要：</p>

<pre><code>General setup —&gt;
[*] Kprobes
[*] Enable loadable module support —&gt;
Kernel hacking —&gt;
[*] Debug Filesystem
[*] Compile the kernel with debug info
</code></pre>

<p>如果是Distro，需要安装Linux内核调试镜像和Linux内核源码包和开发包。</p>

<p>只有这样，Kernel才能被GDB加载调试。</p>

<p>以Fedora为例，当完成了以上步骤后，直接</p>

<pre><code>sudo gdb /usr/lib/debug/lib/modules/3.14.8-200.fc20.x86_64/vmlinux -ex 'target remote /sys/kernel/debug/gtp'
</code></pre>

<p>根据使用内核版本的不同，加载的kernel image路径会有稍许区别，比如上面的<code>3.14.8-200.fc20.x86_64</code>。</p>

<p>至此，部署完毕。</p>

<h4>6. 如何使用KGTP</h4>

<p>请参考KGTP的使用手册，具体链接见：[5]和[6]。</p>

<h4>7. 参考链接</h4>

<ul>
<li> [1] <a href="http://teawater.github.io/kgtp/index.html">http://teawater.github.io/kgtp/index.html</a></li>
<li> [2] <a href="http://kernel.org/doc/ols/2007/ols2007v1-pages-215-224.pdf">http://kernel.org/doc/ols/2007/ols2007v1-pages-215-224.pdf</a></li>
<li> [3] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html</a></li>
<li> [4] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Packets.html</a></li>
<li> [5] <a href="http://teawater.github.io/kgtp/kgtp.html">http://teawater.github.io/kgtp/kgtp.html</a></li>
<li> [6] <a href="http://teawater.github.io/kgtp/kgtpcn.html">http://teawater.github.io/kgtp/kgtpcn.html</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
